// Импорт необходимых библиотек
import { Telegraf, Markup, Context, session } from 'telegraf';
import { Pool } from 'pg';
import { BotCommand } from 'telegraf/types';
import { GoogleSpreadsheet, GoogleSpreadsheetWorksheet } from 'google-spreadsheet';
import { JWT } from 'google-auth-library';

const MAX_SEATS_PER_USER_BEFORE_THRESHOLD = Number(process.env.MAX_SEATS_BEFORE_THRESHOLD ?? 2);
const MAX_SEATS_PER_USER_AFTER_THRESHOLD = Number(process.env.MAX_SEATS_AFTER_THRESHOLD ?? 1);

interface SessionData {
    step?: string;
    userId?: number;
    selectedRow?: number;
    selectedSection?: string;
    selectedSeat?: number;
    selectedSeats?: { section: string; row: number; seat: number }[];
    fullName?: string;
    phoneNumber?: string;
    lockId?: string;
    timerMessageId?: number;
    timerInterval?: NodeJS.Timeout;
    timerStartTime?: number;
}

interface TgContext extends Context {
    session?: SessionData;
}
const booking_sheet_name = process.env.BOOKING_SHEET;
if (booking_sheet_name == undefined) {
    console.error('Booking sheet name is not defined');
}
const token = process.env.BOT_TOKEN;
if (token == undefined) {
    console.error('Token is not defined');
}
// Инициализация Telegram Bot API
const bot = new Telegraf<TgContext>(token!);
bot.use(session());

// Define the bot commands
const commands: BotCommand[] = [
    { command: 'start', description: 'Запустить бота' },
    { command: 'book', description: 'Начать бронирование' },
    { command: 'mybookings', description: 'Посмотреть забронированные места' },
    { command: 'cancel', description: 'Отменить бронь' },
];

// Set the bot commands when the bot starts
bot.telegram.setMyCommands(commands)
    .then(() => {
        console.log('Bot commands set successfully.');
    })
    .catch((error) => {
        console.error('Error setting bot commands:', error);
    });

// Инициализация подключения к базе данных PostgreSQL
const pool = new Pool({
    user: 'postgres',
    host: 'tandem_db',
    database: process.env.DB_NAME ?? 'bot',
    password: 'postgres',
    port: 5432,
});

// Создание таблиц для хранения данных (выполняется один раз)
(async () => {
    const client = await pool.connect();
    try {
        await client.query(`
      CREATE TABLE IF NOT EXISTS sections (
        id SERIAL PRIMARY KEY,
        name TEXT NOT NULL
      );

      CREATE TABLE IF NOT EXISTS rows (
        id SERIAL PRIMARY KEY,
        section_id INTEGER NOT NULL REFERENCES sections(id),
        row_number INTEGER NOT NULL
      );

      CREATE TABLE IF NOT EXISTS users (
        id SERIAL PRIMARY KEY,
        full_name TEXT NOT NULL,
        phone_number TEXT NOT NULL UNIQUE,
        telegram_id BIGINT NOT NULL UNIQUE
      );

      CREATE TABLE IF NOT EXISTS seats (
        id SERIAL PRIMARY KEY,
        row_id INTEGER NOT NULL REFERENCES rows(id),
        seat_number INTEGER NOT NULL,
        is_booked BOOLEAN DEFAULT FALSE,
        booked_by INTEGER REFERENCES users(id)
      );

      CREATE TABLE IF NOT EXISTS temp_locks (
        id SERIAL PRIMARY KEY,
        section_name TEXT NOT NULL,
        row_number INTEGER NOT NULL,
        seat_number INTEGER NOT NULL,
        locked_by TEXT NOT NULL,
        created_at TIMESTAMP NOT NULL DEFAULT NOW(),
        UNIQUE(section_name, row_number, seat_number)
      );

      CREATE INDEX IF NOT EXISTS users_telegram_id ON users (telegram_id);
      CREATE INDEX IF NOT EXISTS temp_locks_seat ON temp_locks (section_name, row_number, seat_number);
    `);
    } catch (error) {
        console.error('Error creating tables:', error);
    } finally {
        client.release();
    }
})();

const serviceAccountAuth = new JWT({
    // env var values here are copied from service account credentials generated by google
    // see "Authentication" section in docs for more info
    email: process.env.GOOGLE_SERVICE_ACCOUNT_EMAIL,
    key: process.env.GOOGLE_PRIVATE_KEY?.replace(/\\n/g, '\n'),
    scopes: ['https://www.googleapis.com/auth/spreadsheets'],
});


if (process.env.GOOGLE_SHEET_ID == undefined)
    console.error('Define google sheet id')

// Google Sheets configuration
const doc = new GoogleSpreadsheet(process.env.GOOGLE_SHEET_ID!, serviceAccountAuth);
const bookingsDoc = new GoogleSpreadsheet(process.env.GOOGLE_SHEET_BOOKINGS_ID!, serviceAccountAuth);

// Add this error handler function at the top of the file, after imports
function handleTelegramError(error: any, operation: string) {
  if (error.description) {
    if (error.description.includes('message is not modified') || 
        error.description.includes('query is too old') ||
        error.description.includes('query ID is invalid')) {
      console.log(`Telegram API non-critical error during ${operation}: ${error.description}`);
      return; // Non-critical error, just log it
    }
  }
  console.error(`Error during ${operation}:`, error);
}

// Обработчик команды /start
bot.start(async (ctx) => {
    ctx.reply(`Добро пожаловать в в систему бронирования мест на ЗОК 2025 в ${process.env.EVENT_TIME ?? '12:30'}. Введите /book для начала бронирования.`);
});

// Обработчик команды /book
const BOOKING_STEPS = {
    SELECT_SECTION: 'select_section',
    SELECT_ROW: 'select_row',
    SELECT_SEAT: 'select_seat',
    CONFIRM: 'confirm',
    AWAITING_FULL_NAME: 'awaiting_full_name',
    AWAITING_PHONE_NUMBER: 'awaiting_phone_number',
};

async function startBooking(ctx: TgContext) {
    ctx.session = { selectedSeats: [], step: BOOKING_STEPS.SELECT_SECTION };
    const sections = await getSections();

    if (sections.length === 0) {
        return ctx.reply('Нет доступных секций.');
    }

    const sectionButtons = sections.map((section) =>
        Markup.button.callback(section.name, `section_${section.name}`)
    );

    return ctx.reply('Выберите секцию:', Markup.inlineKeyboard(sectionButtons, { columns: 2 }));
}

// Обработчик команды /book
bot.command('book', startBooking);


bot.action(/^cancel_section_(.+)/, async (ctx) => {
    const sectionName = ctx.match[1];
    if (ctx.session == undefined) {
        return;
    }
    ctx.session.selectedSection = sectionName;
    // Get cancellable rows for this user in this section
    const rows = await getCancellableRows(sectionName, ctx);
    const sectionButtons = rows.map((row) =>
        Markup.button.callback(`Ряд ${row.row_number}`, `cancel_row_${sectionName}_${row.row_number}`)
    );
    sectionButtons.push(Markup.button.callback('Отмена', 'cancel_booking'));
    try {
        await ctx.editMessageText(`Выберите ряд для отмены (Секция ${sectionName}):`, Markup.inlineKeyboard(sectionButtons, { columns: 3 }));
    }
    catch (error) {
        handleTelegramError(error, "cancel section update text");
    }
    try {
        await ctx.answerCbQuery();
    } catch (error) {
        handleTelegramError(error, "answering callback query for cancel section");
    }
});

bot.action(/^cancel_row_(.+)_(.+)/, async (ctx) => {
    const sectionName = ctx.match[1];
    const rowNumber = parseInt(ctx.match[2], 10);
    if (ctx.session == undefined) {
        return;
    }
    ctx.session.selectedRow = rowNumber;


    const seats = await getCancellableSeats(sectionName, rowNumber, ctx);

    const selectedSeats = ctx.session?.selectedSeats || [];

    const rowButtons = seats.map((seat) => {
        let label = `Место ${seat.seat_number}`;
        if (selectedSeats.some(s => s.section === sectionName && s.row === rowNumber && s.seat === seat.seat_number)) {
            label += " ✅"; // Mark selected seats
        }
        return Markup.button.callback(label, `cancel_seat_${sectionName}_${rowNumber}_${seat.seat_number}`);
    });

    rowButtons.push(Markup.button.callback('Назад', `cancel_back_to_row_${sectionName}`));
    if (selectedSeats.length > 0) {
        rowButtons.push(Markup.button.callback('Подтвердить отмену', 'confirm_cancellation'));
    }
    rowButtons.push(Markup.button.callback('Отмена', 'cancel_booking'));
    try {
        await ctx.editMessageText(`Выберите места для отмены (Секция ${sectionName}, Ряд ${rowNumber}):`, Markup.inlineKeyboard(rowButtons, { columns: 3 }));
    }
    catch (error) {
        handleTelegramError(error, "cancel row update text");
    }
    try {
        await ctx.answerCbQuery();
    } catch (error) {
        handleTelegramError(error, "answering callback query for cancel row");
    }
});


bot.action(/cancel_seat_(.+)_(.+)_(.+)/, async (ctx) => {
    const [sectionName, rowNumberStr, seatNumberStr] = ctx.match.slice(1);
    const rowNumber = parseInt(rowNumberStr, 10);
    const seatNumber = parseInt(seatNumberStr, 10);

    if (ctx.session == undefined) {
        return;
    }

    ctx.session.selectedSeats = ctx.session.selectedSeats || [];

    const seatInfo = { section: sectionName, row: rowNumber, seat: seatNumber };

    const existingSeatIndex = ctx.session.selectedSeats.findIndex(
        (s) => s.section === sectionName && s.row === rowNumber && s.seat === seatNumber
    );

    if (existingSeatIndex > -1) {
        ctx.session.selectedSeats.splice(existingSeatIndex, 1); // Remove if already selected
        try {
            await ctx.answerCbQuery(`Место ${seatNumber} снято с отмены.`);
        } catch (error) {
            handleTelegramError(error, "answering callback query for cancel seat removal");
        }
    } else {
        ctx.session.selectedSeats.push(seatInfo); // Add to selected seats
        try {
            await ctx.answerCbQuery(`Место ${seatNumber} добавлено к отмене.`);
        } catch (error) {
            handleTelegramError(error, "answering callback query for cancel seat addition");
        }
    }

    // Re-render the seats buttons with updated selection
    const seats = await getCancellableSeats(sectionName, rowNumber, ctx);
    const selectedSeats = ctx.session?.selectedSeats || [];

    const rowButtons = seats.map((seat) => {
        let label = `Место ${seat.seat_number}`;
        if (selectedSeats.some(s => s.section === sectionName && s.row === rowNumber && s.seat === seat.seat_number)) {
            label += " ✅"; // Mark selected seats
        }
        return Markup.button.callback(label, `cancel_seat_${sectionName}_${rowNumber}_${seat.seat_number}`);
    });

    rowButtons.push(Markup.button.callback('Назад', `cancel_back_to_row_${sectionName}`));
    if (selectedSeats.length > 0) {
        rowButtons.push(Markup.button.callback('Подтвердить отмену', 'confirm_cancellation'));
    }
    rowButtons.push(Markup.button.callback('Отмена', 'cancel_booking'));
    try {
        await ctx.editMessageText(`Выберите места для отмены (Секция ${sectionName}, Ряд ${rowNumber}):`, Markup.inlineKeyboard(rowButtons, { columns: 3 }));
    }
    catch (error) {
        handleTelegramError(error, "cancel seat update text");
    }
});

let usersWithTwoSeatsCache = 0;

async function refreshUsersWithTwoSeatsCache() {
    const client = await pool.connect();
    try {
        // Count users who have 2 or more booked seats
        const { rows } = await client.query(`
            SELECT COUNT(*) FROM (
                SELECT booked_by, COUNT(*) as seat_count
                FROM seats
                WHERE is_booked = TRUE AND booked_by IS NOT NULL
                GROUP BY booked_by
                HAVING COUNT(*) >= 2
            ) AS users_with_two
        `);
        usersWithTwoSeatsCache = parseInt(rows[0].count, 10);
    } finally {
        client.release();
    }
}

setInterval(refreshUsersWithTwoSeatsCache, 10 * 1000); // every 10 seconds
refreshUsersWithTwoSeatsCache(); // initial call

function getCurrentUserSeatLimitCached(): number {
    return usersWithTwoSeatsCache < 248
        ? MAX_SEATS_PER_USER_BEFORE_THRESHOLD
        : MAX_SEATS_PER_USER_AFTER_THRESHOLD;
}

bot.action('confirm_cancellation', async (ctx) => {
    if (!ctx.session || !ctx.session.selectedSeats || ctx.session.selectedSeats.length === 0) {
        return ctx.reply('Вы не выбрали места для отмены.');
    }

    try {
        await ctx.deleteMessage();
    } catch (error) {
        handleTelegramError(error, "deleting message during cancellation confirmation");
    }

    const client = await pool.connect();
    try {
        const userId = (await client.query(`SELECT id FROM users WHERE telegram_id = $1`, [ctx.from?.id]))?.rows?.[0]?.id;

        if (!userId) {
            ctx.reply('У вас нет активных броней.');
            return;
        }

        try {
            await updateSeatsAndSheet(ctx.session.selectedSeats, userId, false, ctx);
            // Update cache after cancellation
            await refreshUsersWithTwoSeatsCache();
            ctx.reply(`${ctx.session.selectedSeats.length} мест(а) успешно отменено.`);
            ctx.session.step = undefined; // Clear the session after cancellation
            ctx.session.selectedSeats = []; // Clear selected seats
        } catch (error) {
            // Error is already handled in updateSeatsAndSheet
        }

    } catch (error) {
        console.error('Error during initial phase of seat cancellation (fetching userId):', error);
        ctx.reply('Произошла ошибка при отмене бронирования. Пожалуйста, попробуйте снова.');

    } finally {
        client.release();
        try {
            await ctx.answerCbQuery();
        } catch (error) {
            handleTelegramError(error, "answering callback query after cancellation confirmation");
        }
    }
});

// Action handler for 'back' button during cancellation
bot.action(/^cancel_back_to_row_(.+)/, async (ctx) => {
    const sectionName = ctx.match[1];
    if (ctx.session) {
        ctx.session.selectedRow = undefined; // Reset selected row in session
        const rows = await getCancellableRows(sectionName, ctx);
        const rowButtons = rows.map((row) =>
            Markup.button.callback(`Ряд ${row.row_number}`, `cancel_row_${sectionName}_${row.row_number}`)
        );


        rowButtons.push(Markup.button.callback('Отмена', 'cancel_booking'));
        try {
            await ctx.editMessageText(`Выберите ряд для отмены (Секция ${sectionName}):`, Markup.inlineKeyboard(rowButtons, { columns: 3 }));
        }
        catch (error) {
            handleTelegramError(error, "cancel back to row update text");
        }
        try {
            await ctx.answerCbQuery();
        } catch (error) {
            handleTelegramError(error, "answering callback query for cancel back to row");
        }
    }
});

// Обработчики кнопок выбора секции, ряда и места
bot.action(/section_(.+)/, async (ctx) => {
    const sectionName = ctx.match[1];
    if (ctx.session == undefined) {
        return ctx.reply('Введите /book для начала бронирования.');
    }
    ctx.session.selectedSection = sectionName;
    ctx.session.step = BOOKING_STEPS.SELECT_ROW;

    const rows = await getRows(sectionName);
    const sectionButtons = rows.map((row) =>
        Markup.button.callback(`Ряд ${row.row_number} (${row.free_seats}/${row.total_seats})`, `row_${sectionName}_${row.row_number}`)
    );
    sectionButtons.push(Markup.button.callback('Назад', 'back_to_section'));
    sectionButtons.push(Markup.button.callback('Отмена', 'cancel_booking')); // Add cancel button

    const selectedSeatsString = getSelectedSeatsString(ctx);
    try {
        await ctx.editMessageText(`Выбранные места:\n${selectedSeatsString}\n\nТекущий выбор:\nCекция ${sectionName}\nВыберите ряд:`, Markup.inlineKeyboard(sectionButtons, { columns: 3 }));
    }
    catch (error) {
        handleTelegramError(error, "select section update text");
    }
    try {
        await ctx.answerCbQuery();
    } catch (error) {
        handleTelegramError(error, "answering callback query for section selection");
    }
});

bot.action(/row_(.+)_(.+)/, async (ctx) => {
    const sectionName = (ctx.match[1]);
    const rowNumber = (ctx.match[2]);
    if (ctx.session == undefined) {
        return ctx.reply('Введите /book для начала бронирования.');
    }
    ctx.session.selectedRow = parseInt(rowNumber, 10);
    ctx.session.step = BOOKING_STEPS.SELECT_SEAT;
    const seats = await getSeats(sectionName, parseInt(rowNumber, 10), ctx);
    const rowButtons = seats.map((seat) => { // Use seats with isBookedByUser
        let label = `Место ${seat.seat_number}`;
        if (seat.isSelected) {
            label += " ✅";
        } else if (seat.isBookedByUser) {
            label += " 👤";
        }
        else if (seat.isBooked) {
            label += ' ❌';
        }
        return Markup.button.callback(label, `seat_${sectionName}_${parseInt(rowNumber, 10)}_${seat.seat_number}`);
    });
    rowButtons.push(Markup.button.callback('Назад', `back_to_row_${sectionName}`));
    rowButtons.push(Markup.button.callback('Отмена', 'cancel_booking')); // Add cancel button
    if (ctx.session.selectedSeats != undefined && ctx.session.selectedSeats.length! > 0) {
        rowButtons.push(Markup.button.callback('Подтвердить', 'confirm_booking'));
    }

    const selectedSeatsString = getSelectedSeatsString(ctx);
    try {
        await ctx.editMessageText(`Выбранные места:\n${selectedSeatsString}\n\nТекущий выбор:\nCекция ${sectionName}, Ряд ${rowNumber}\nВыберите место:`, Markup.inlineKeyboard(rowButtons, { columns: 3 }));
    }
    catch (error) {
        handleTelegramError(error, "select row update text");
    }
    try {
        await ctx.answerCbQuery();
    } catch (error) {
        handleTelegramError(error, "answering callback query for row selection");
    }
});


bot.action(/seat_(.+)_(.+)_(.+)/, async (ctx) => {
    const [sectionName, rowNumber, seatNumber] = ctx.match.slice(1);
    if (!ctx.session || !ctx.session.selectedSeats) {
        return ctx.reply('Введите /book для начала бронирования.');
    }

    const seatInfo = {
        section: sectionName,
        row: parseInt(rowNumber, 10),
        seat: parseInt(seatNumber, 10),
    };

    const existingSeatIndex = ctx.session.selectedSeats.findIndex(
        (s) => s.section === seatInfo.section && s.row === seatInfo.row && s.seat === seatInfo.seat
    );

    var seats = await getSeats(sectionName, parseInt(rowNumber, 10), ctx);
    const selectedSeat = seats.find(seat => seat.seat_number === parseInt(seatNumber)); // Находим selectedSeat

    if (existingSeatIndex > -1) {
        ctx.session.selectedSeats.splice(existingSeatIndex, 1);
        try {
            await ctx.answerCbQuery(`Место ${seatNumber} снято с брони.`);
        } catch (error) {
            handleTelegramError(error, "answering callback query for seat removal");
        }
    } else if (!selectedSeat?.isBookedByUser && !selectedSeat?.isBooked) { // Проверка на undefined и isBookedByUser
        // Check if adding this seat exceeds the limit
        const currentLimit = getCurrentUserSeatLimitCached();
        if (ctx.session.selectedSeats.length >= currentLimit) {
            try {
                await ctx.answerCbQuery(`Вы можете забронировать максимум ${currentLimit} места.`);
            } catch (error) {
                handleTelegramError(error, "answering callback query for seat limit");
            }
            return;
        }

        const client = await pool.connect();

        try {
            const userBookings = await client.query(
                `SELECT COUNT(*) FROM seats WHERE booked_by = (SELECT id FROM users WHERE telegram_id = $1)`,
                [ctx.from.id]
            )

            if (parseInt(userBookings.rows[0].count) + ctx.session.selectedSeats.length >= currentLimit) {
                try {
                    await ctx.answerCbQuery(`Вы можете забронировать максимум ${currentLimit} места.`);
                } catch (error) {
                    handleTelegramError(error, "answering callback query for user booking limit");
                }
                return;
            }

        } catch (error) {
            console.log("Failed to get user bookings")
        } finally {
            client.release();
        }

        ctx.session.selectedSeats.push(seatInfo);
        try {
            await ctx.answerCbQuery(`Место ${seatNumber} добавлено к брони.`);
        } catch (error) {
            handleTelegramError(error, "answering callback query for seat addition");
        }
    } else if (selectedSeat?.isBookedByUser) {
        try {
            await ctx.answerCbQuery('Это место уже забронировано вами.');
        } catch (error) {
            handleTelegramError(error, "answering callback query for already booked by user");
        }
        return;
    }
    else {
        try {
            await ctx.answerCbQuery('Это место уже занято.');
        } catch (error) {
            handleTelegramError(error, "answering callback query for already booked seat");
        }
        return;
    }

    seats = await getSeats(sectionName, parseInt(rowNumber, 10), ctx);

    const seatButtons = seats.map((seat) => {
        let label = `Место ${seat.seat_number}`;
        if (seat.isSelected) {
            label += ' ✅';
        } else if (seat.isBookedByUser) {
            label += ' 👤';
        }
        else if (seat.isBooked) {
            label += ' ❌';
        }
        return Markup.button.callback(label, `seat_${sectionName}_${parseInt(rowNumber, 10)}_${seat.seat_number}`);
    });

    seatButtons.push(Markup.button.callback('Назад', `back_to_row_${sectionName}`));
    seatButtons.push(Markup.button.callback('Отмена', 'cancel_booking'));
    if (ctx.session.selectedSeats.length > 0) {
        seatButtons.push(Markup.button.callback('Подтвердить', 'confirm_booking'));
    }

    const selectedSeatsString = getSelectedSeatsString(ctx);

    try {
        //  Объединяем обновление текста и кнопок в один вызов editMessageText
        await ctx.editMessageText(
            `Выбранные места:\n${selectedSeatsString}\n\nТекущий выбор:\nСекция ${sectionName}, Ряд ${rowNumber}\nВыберите место:`,
            Markup.inlineKeyboard(seatButtons, { columns: 3 })
        );
    } catch (error) {
        handleTelegramError(error, "updating seat selection message");
    }
});

// Add these utility functions after imports but before the main code
// Utility function for exponential backoff with improved error handling
async function withRetry<T>(operation: () => Promise<T>, maxRetries = 5, ctx?: TgContext, operationName = "операция"): Promise<{ success: boolean; data?: T; error?: any }> {
  let lastError: any;
  let userNotified = false;
  let loadingMessageId: number | undefined;
  
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      const result = await operation();
      
      // Clean up waiting message if operation succeeds
      if (userNotified && ctx && loadingMessageId) {
        try {
          await ctx.telegram.deleteMessage(ctx.chat!.id, loadingMessageId);
        } catch (error) {
          console.error('Error deleting waiting message:', error);
        }
      }
      
      return { success: true, data: result };
    } catch (error: any) {
      lastError = error;
      // Check if it's a rate limit error (429)
      if (error.code === 429 || (error.response && error.response.status === 429)) {
        console.log(`Rate limit exceeded (attempt ${attempt + 1}/${maxRetries}), backing off...`);
        
        // Notify user only once about waiting
        if (!userNotified && ctx && ctx.chat) {
          try {
            const backoffTime = Math.pow(2, attempt) * 1000;
            const waitSeconds = Math.ceil(backoffTime / 1000);
            const message = await ctx.reply(`Ожидайте, ${operationName} выполняется... ⏳ (${waitSeconds}с)`);
            loadingMessageId = message.message_id;
            userNotified = true;
          } catch (msgError) {
            console.error('Error sending waiting message:', msgError);
            // Continue even if message sending fails
          }
        }
        
        // Exponential backoff: 1s, 2s, 4s, 8s, 16s...
        const backoffTime = Math.pow(2, attempt) * 1000;
        await new Promise(resolve => setTimeout(resolve, backoffTime));
        continue;
      }
      
      // For non-rate-limit errors, clean up message and return error
      if (userNotified && ctx && loadingMessageId) {
        try {
          await ctx.telegram.deleteMessage(ctx.chat!.id, loadingMessageId);
        } catch (delError) {
          console.error('Error deleting waiting message:', delError);
        }
      }
      
      // Return failure for non-rate-limit errors immediately
      console.error(`Operation failed with error:`, error);
      return { success: false, error };
    }
  }
  
  // If we got here, we've exhausted all retries
  // Show failure message to user if appropriate
  if (userNotified && ctx && loadingMessageId) {
    try {
      await ctx.telegram.deleteMessage(ctx.chat!.id, loadingMessageId);
      // Show a failure message instead
      await ctx.reply(`Не удалось выполнить ${operationName} из-за ограничений сервера. Пожалуйста, попробуйте позже.`);
    } catch (error) {
      console.error('Error handling final retry failure messages:', error);
    }
  }
  
  console.error(`Failed after ${maxRetries} retries:`, lastError);
  return { success: false, error: lastError };
}

// Update checkCellColorBulk to handle the new retry result format
async function checkCellColorBulk(seats: { section: string; row: number; seat: number }[], ctx?: TgContext): Promise<{ [key: string]: boolean | null }> {
  try {
    const retryResult = await withRetry(async () => {
      await doc.loadInfo();
      const results: { [key: string]: boolean | null } = {};
      
      const sheetsToLoad: { [section: string]: boolean } = {};
      
      for (const seat of seats) {
        if (!sheetsToLoad[seat.section]) {
          sheetsToLoad[seat.section] = true;
        }
      }
      
      const sheetPromises = Object.keys(sheetsToLoad).map(async sectionName => {
        const sheet = doc.sheetsByTitle[sectionName];
        if (sheet) {
          await sheet.loadCells('A1:AH30');
          return { sectionName, sheet };
        }
        return null;
      });
      
      const loadedSheets = await Promise.all(sheetPromises);
      
      const sheetsBySection: { [sectionName: string]: GoogleSpreadsheetWorksheet } = {};
      for (const loadedSheet of loadedSheets) {
        if (loadedSheet) {
          sheetsBySection[loadedSheet.sectionName] = loadedSheet.sheet;
        }
      }
      
      for (const seat of seats) {
        const sheet = sheetsBySection[seat.section];
        
        if (!sheet) {
          results[`${seat.section}-${seat.row}-${seat.seat}`] = null;
          continue;
        }
        
        const colLetter = numToColLetter(seat.seat);
        const cell = sheet.getCellByA1(`${colLetter}${seat.row}`);
        const isBooked = cell.value;
        
        if (typeof isBooked === 'boolean') {
          results[`${seat.section}-${seat.row}-${seat.seat}`] = isBooked;
        } else if (isBooked === "TRUE" || isBooked === "FALSE") {
          results[`${seat.section}-${seat.row}-${seat.seat}`] = isBooked === "TRUE";
        } else {
          results[`${seat.section}-${seat.row}-${seat.seat}`] = null;
        }
      }
      
      return results;
    }, 5, ctx, "проверка доступности мест");
    
    if (retryResult.success && retryResult.data) {
      return retryResult.data;
    } else {
      // If we failed after retries, mark all seats as potentially booked to be safe
      console.error('Failed to check cell colors after retries:', retryResult.error);
      if (ctx) {
        ctx.reply('Не удалось проверить доступность мест. Для безопасности считаем их забронированными.');
      }
      
      const safeResults: { [key: string]: boolean | null } = {};
      for (const seat of seats) {
        safeResults[`${seat.section}-${seat.row}-${seat.seat}`] = true; // Mark as booked to be safe
      }
      return safeResults;
    }
  } catch (error) {
    console.error('Error in checkCellColorBulk:', error);
    return {}; // Return empty object as fallback
  }
}

// Update updateSeatsAndSheet to handle the new retry result format
async function updateSeatsAndSheet(seats: { section: string; row: number; seat: number }[], userId: number, isBooking: boolean, ctx: TgContext) {
  const client = await pool.connect();
  try {
    await client.query('BEGIN'); // Start transaction

    // First update database since it's more reliable
    const updatedSeats: { section: string; row: number; seat: number }[] = [];
    for (const seat of seats) {
      const query = `
        UPDATE seats 
        SET is_booked = $1, booked_by = $2
        WHERE row_id = (SELECT id FROM rows WHERE section_id = (SELECT id FROM sections WHERE name = $3) AND row_number = $4)
        AND seat_number = $5
        RETURNING *;
      `;

      const values = [isBooking, isBooking ? userId : null, seat.section, seat.row, seat.seat];
      const { rowCount, rows: updatedRows } = await client.query(query, values);

      if (rowCount !== 1) {
        throw new Error(`Failed to update seat: ${seat.section}, ${seat.row}, ${seat.seat}. Row count: ${rowCount}`);
      }
      
      updatedSeats.push(seat);
    }

    // Now update Google Sheets with retry logic
    try {
      const retryResult = await withRetry(async () => {
        await doc.loadInfo();
        
        const sheetsToUpdate: { [section: string]: GoogleSpreadsheetWorksheet } = {};
        
        // Batch updates by section to minimize API calls
        for (const seat of updatedSeats) {
          let sheet = sheetsToUpdate[seat.section];
          
          if (!sheet) {
            sheet = doc.sheetsByTitle[seat.section];
            if (!sheet) {
              sheet = await doc.addSheet({ title: seat.section });
            }
            
            await sheet.loadCells('A1:AH30');
            sheetsToUpdate[seat.section] = sheet;
          }
          
          const colLetter = numToColLetter(seat.seat);
          const cell = sheet.getCellByA1(`${colLetter}${seat.row}`);
          cell.value = isBooking;
        }
        
        // Save updates one sheet at a time with a small delay to avoid rate limits
        for (const sheet of Object.values(sheetsToUpdate)) {
          await sheet.saveUpdatedCells();
          // Add a short delay between sheet updates
          await new Promise(resolve => setTimeout(resolve, 200));
        }
        
        return true; // Operation succeeded
      }, 5, ctx, isBooking ? "бронирование" : "отмена бронирования");
      
      if (retryResult.success) {
        await client.query('COMMIT');
        return true;
      } else {
        // We updated the database but failed to update Google Sheets
        // Since database is our source of truth, we can commit anyway but warn the user
        await client.query('COMMIT');
        console.warn('Database updated but Google Sheets update failed. Will sync on next background job.');
        ctx.reply(`${isBooking ? 'Бронирование' : 'Отмена брони'} выполнена успешно, но обновление таблицы произойдет с задержкой.`);
        return true;
      }
    } catch (error) {
      await client.query('ROLLBACK');
      console.error('Error updating Google Sheets:', error);
      ctx.reply('Произошла ошибка при обновлении. Попробуйте снова.');
      return false;
    }
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('Error updating seats:', error);
    ctx.reply('Произошла ошибка при обновлении. Попробуйте снова.');
    return false;
  } finally {
    client.release();
  }
}

async function getSections() {
    const client = await pool.connect();
    try {
        const { rows } = await client.query('SELECT name FROM sections');
        return rows;
    } finally {
        client.release();
    }
}


async function getRows(sectionName: string) {
    const client = await pool.connect();
    try {
        const { rows } = await client.query(
            `SELECT rows.row_number, COUNT(seats.id) AS total_seats,
             (SELECT COUNT(s.id) FROM seats s JOIN rows r ON s.row_id = r.id JOIN sections sec ON r.section_id = sec.id WHERE sec.name = $1 AND r.row_number = rows.row_number AND s.is_booked = FALSE) AS free_seats
             FROM rows
             JOIN sections ON rows.section_id = sections.id
             LEFT JOIN seats ON rows.id = seats.row_id
             WHERE sections.name = $1
             GROUP BY rows.row_number
             ORDER BY rows.row_number ASC`, // Add ORDER BY clause here
            [sectionName]
        );
        return rows;
    } finally {
        client.release();
    }
}


async function getSeats(sectionName: string, rowNumber: number, ctx: TgContext) {
    const client = await pool.connect();
    try {
        const { rows } = await client.query(
            `SELECT seats.seat_number, seats.booked_by, seats.is_booked
             FROM seats
             JOIN rows ON seats.row_id = rows.id
             JOIN sections ON rows.section_id = sections.id
             WHERE sections.name = $1
             AND rows.row_number = $2
             ORDER BY seats.seat_number;`, // ORDER BY для упорядочивания
            [sectionName, rowNumber]
        );

        const selectedSeats = ctx.session?.selectedSeats || [];
        const userId = (await client.query(`SELECT id FROM users WHERE telegram_id = $1`, [ctx.from?.id]))?.rows?.[0]?.id;

        const seatsWithSelection = rows.map(seat => ({
            ...seat,
            isSelected: selectedSeats.some(s => s.section === sectionName && s.row === rowNumber && s.seat === seat.seat_number),
            isBookedByUser: seat.booked_by === userId,
            isBooked: seat.is_booked
        }));

        return seatsWithSelection;
    } finally {
        client.release();
    }
}

function getSelectedSeatsString(ctx: TgContext) {
    return ctx.session && ctx.session.selectedSeats ? ctx.session.selectedSeats.map(s => `Секция ${s.section}, Ряд ${s.row}, Место ${s.seat}`).join('\n') : "";
}

// Add countdown timer message and seat suggestion functions
async function startBookingTimer(ctx: TgContext): Promise<number | undefined> {
    try {
        const message = await ctx.reply('⏱ У вас есть 5 минут для завершения бронирования...');
        return message.message_id;
    } catch (error) {
        console.error('Error sending timer message:', error);
        return undefined;
    }
}

async function updateBookingTimer(ctx: TgContext, messageId: number, timeLeft: number): Promise<void> {
    try {
        const minutes = Math.floor(timeLeft / 60);
        const seconds = timeLeft % 60;
        await ctx.telegram.editMessageText(
            ctx.chat!.id, 
            messageId,
            undefined, 
            `⏱ У вас есть ${minutes}:${seconds < 10 ? '0' + seconds : seconds} для завершения бронирования...`
        );
    } catch (error) {
        console.error('Error updating timer message:', error);
    }
}

async function findAlternativeSeats(section: string, row: number, seat: number, ctx: TgContext): Promise<{ section: string; row: number; seat: number }[]> {
    const client = await pool.connect();
    try {
        // First try same row, nearby seats
        const { rows: sameRowSeats } = await client.query(
            `SELECT sections.name as section_name, rows.row_number, seats.seat_number
             FROM seats
             JOIN rows ON seats.row_id = rows.id
             JOIN sections ON rows.section_id = sections.id
             WHERE sections.name = $1 AND rows.row_number = $2 AND seats.is_booked = FALSE
             AND ABS(seats.seat_number - $3) <= 3
             ORDER BY ABS(seats.seat_number - $3)
             LIMIT 3`,
            [section, row, seat]
        );
        
        if (sameRowSeats.length > 0) {
            return sameRowSeats.map(s => ({ 
                section: s.section_name, 
                row: s.row_number, 
                seat: s.seat_number 
            }));
        }
        
        // Try nearby rows in same section
        const { rows: nearbyRowSeats } = await client.query(
            `SELECT sections.name as section_name, rows.row_number, seats.seat_number
             FROM seats
             JOIN rows ON seats.row_id = rows.id
             JOIN sections ON rows.section_id = sections.id
             WHERE sections.name = $1 
             AND ABS(rows.row_number - $2) <= 2
             AND rows.row_number != $2
             AND seats.is_booked = FALSE
             ORDER BY ABS(rows.row_number - $2), ABS(seats.seat_number - $3)
             LIMIT 3`,
            [section, row, seat]
        );
        
        return nearbyRowSeats.map(s => ({ 
            section: s.section_name, 
            row: s.row_number, 
            seat: s.seat_number 
        }));
    } catch (error) {
        console.error('Error finding alternative seats:', error);
        return [];
    } finally {
        client.release();
    }
}

function formatSeatSuggestion(seat: { section: string; row: number; seat: number }): string {
    return `Секция ${seat.section}, Ряд ${seat.row}, Место ${seat.seat}`;
}

// Generate a rich booking confirmation message
function createBookingConfirmation(
    fullName: string | undefined, 
    phoneNumber: string | undefined, 
    seats: { section: string; row: number; seat: number }[]
): string {
    const seatsText = seats.map(s => `• Секция ${s.section}, Ряд ${s.row}, Место ${s.seat}`).join('\n');
    
    return `🎟 *Бронирование подтверждено!*

*Информация о бронировании:*
👤 ФИО: ${fullName || 'Не указано'}
📞 Телефон: ${phoneNumber || 'Не указано'}

*Забронированные места:*
${seatsText}

*Что дальше?*
• Используйте /mybookings для просмотра всех ваших бронирований
• Используйте /cancel для отмены брони
• Используйте /book для бронирования дополнительных мест`;
}

// Обработчик кнопок "Подтвердить"
bot.action('confirm_booking', async (ctx) => {
    if (!ctx.session?.selectedSeats || ctx.session.selectedSeats.length === 0) {
        return ctx.reply('Вы не выбрали места для бронирования. Введите /book для выбора мест.');
    }

    // Clear previous timer if exists
    if (ctx.session.timerInterval) {
        clearInterval(ctx.session.timerInterval);
        if (ctx.session.timerMessageId) {
            try {
                await ctx.telegram.deleteMessage(ctx.chat!.id, ctx.session.timerMessageId);
            } catch (error) {
                console.error('Error deleting timer message:', error);
            }
        }
    }

    // Start a new booking timer
    const timerMessageId = await startBookingTimer(ctx);
    if (timerMessageId) {
        ctx.session.timerMessageId = timerMessageId;
        ctx.session.timerStartTime = Date.now();
        
        // Set up interval to update the timer every 15 seconds
        const timerInterval = setInterval(async () => {
            if (!ctx.session?.timerStartTime || !ctx.session?.timerMessageId) {
                clearInterval(timerInterval);
                return;
            }
            
            const elapsed = Math.floor((Date.now() - ctx.session.timerStartTime) / 1000);
            const timeLeft = 300 - elapsed; // 5 minutes = 300 seconds
            
            if (timeLeft <= 0) {
                clearInterval(timerInterval);
                try {
                    // Timer expired, release locks
                    if (ctx.session.lockId && ctx.session.selectedSeats) {
                        await releaseTemporaryLocks(ctx.session.selectedSeats, ctx.session.lockId);
                    }
                    
                    // Update the message to show timeout
                    await ctx.telegram.editMessageText(
                        ctx.chat!.id, 
                        ctx.session.timerMessageId, 
                        undefined,
                        '⌛ Время бронирования истекло. Пожалуйста, начните процесс заново.'
                    );
                    
                    // Reset session
                    ctx.session = { selectedSeats: [] };
                    await ctx.reply('Время на бронирование истекло. Выбранные места освобождены. Введите /book, чтобы начать заново.');
                } catch (error) {
                    console.error('Error handling booking timeout:', error);
                }
                return;
            }
            
            await updateBookingTimer(ctx, ctx.session.timerMessageId, timeLeft);
        }, 15000); // Update every 15 seconds
        
        ctx.session.timerInterval = timerInterval;
    }

    await ctx.deleteMessage(); // Delete the seats selection message

    // Create a lock ID for this booking session
    const lockId = generateLockId(ctx);
    ctx.session.lockId = lockId;
    
    // Try to create temporary locks for all selected seats
    const locksCreated = await createTemporaryLocks(ctx.session.selectedSeats, lockId);
    
    if (!locksCreated) {
        ctx.reply('Некоторые из выбранных мест были забронированы другими пользователями. Пожалуйста, выберите другие места.');
        ctx.session.selectedSeats = [];
        ctx.session.step = BOOKING_STEPS.SELECT_SECTION;
        return startBooking(ctx);
    }

    // Now check with Google Sheets to verify availability
    const bookedSeats: { section: string; row: number; seat: number }[] = [];
    const successfullySelectedSeats: { section: string; row: number; seat: number }[] = [];

    try {
        const availability = await checkCellColorBulk(ctx.session.selectedSeats || [], ctx);

        for (const seat of ctx.session.selectedSeats || []) {
            const key = `${seat.section}-${seat.row}-${seat.seat}`;
            const isBooked = availability[key];

            if (isBooked === true || isBooked === null) {
                bookedSeats.push(seat);
            } else {
                successfullySelectedSeats.push(seat)
            }
        }

        if (bookedSeats.length > 0) {
            // Release locks since some seats are unavailable
            await releaseTemporaryLocks(ctx.session.selectedSeats, lockId);
            
            await checkSpreadsheetChanges();
            const bookedSeatsString = bookedSeats.map(s => `Секция ${s.section}, Ряд ${s.row}, Место ${s.seat}`).join('\n');
            
            if (successfullySelectedSeats.length === 0) {
                // All selected seats are unavailable, suggest alternatives
                const suggestions: { section: string; row: number; seat: number }[] = [];
                
                // Try to find alternatives for each booked seat
                for (const seat of bookedSeats) {
                    const alternatives = await findAlternativeSeats(seat.section, seat.row, seat.seat, ctx);
                    for (const alt of alternatives) {
                        // Add only if not already in suggestions
                        if (!suggestions.some(s => 
                            s.section === alt.section && s.row === alt.row && s.seat === alt.seat)) {
                            suggestions.push(alt);
                            if (suggestions.length >= 3) break; // Limit to 3 suggestions total
                        }
                    }
                    if (suggestions.length >= 3) break;
                }
                
                let message = `⚠️ Следующие места уже забронированы:\n${bookedSeatsString}\n\nПожалуйста, выберите другие места.`;
                
                if (suggestions.length > 0) {
                    message += `\n\n💡 Рекомендуемые альтернативы:\n${suggestions.map(formatSeatSuggestion).join('\n')}`;
                }
                
                ctx.reply(message);
                ctx.session.selectedSeats = [];
                ctx.session.step = BOOKING_STEPS.SELECT_SECTION;
                return startBooking(ctx);
            } else {
                ctx.session.selectedSeats = successfullySelectedSeats;
                const lastSelectedSeat = ctx.session.selectedSeats[ctx.session.selectedSeats.length - 1];

                // Try to lock just the successful seats
                const successfulLocksCreated = await createTemporaryLocks(successfullySelectedSeats, lockId);
                
                if (!successfulLocksCreated) {
                    ctx.reply('Извините, но выбранные места были забронированы другим пользователем. Пожалуйста, выберите другие места.');
                    ctx.session.selectedSeats = [];
                    ctx.session.step = BOOKING_STEPS.SELECT_SECTION;
                    return startBooking(ctx);
                }

                const seats = await getSeats(lastSelectedSeat.section, lastSelectedSeat.row, ctx);
                const seatButtons = seats.map(seat => {
                    let label = `Место ${seat.seat_number}`;
                    if (seat.isSelected) {
                        label += " ✅";
                    } else if (seat.isBookedByUser) {
                        label += " 👤";
                    } else if (seat.isBooked) {
                        label += " ❌";
                    }
                    return Markup.button.callback(label, `seat_${lastSelectedSeat.section}_${lastSelectedSeat.row}_${seat.seat_number}`)
                });

                seatButtons.push(Markup.button.callback('Назад', `back_to_row_${lastSelectedSeat.section}`));
                if (ctx.session.selectedSeats.length > 0) {
                    seatButtons.push(Markup.button.callback('Подтвердить', 'confirm_booking'));
                }

                const selectedSeatsString = getSelectedSeatsString(ctx);

                return ctx.reply(`⚠️Некоторые из выбранных вами мест были уже забронированы:\n${bookedSeatsString}\n\nПожалуйста, выберите другие места.\n\nВыбранные места:\n${selectedSeatsString}\n\nТекущий выбор:\nСекция ${lastSelectedSeat.section}, Ряд ${lastSelectedSeat.row}\nВыберите место:`,
                    Markup.inlineKeyboard(seatButtons, { columns: 3 }));
            }
        } else {
            // Proceed to the next step with locks still in place
            ctx.reply('Введите ФИО ребёнка (участника концерта):');
            ctx.session.step = BOOKING_STEPS.AWAITING_FULL_NAME;
        }
    } catch (error) {
        // Release locks on error
        await releaseTemporaryLocks(ctx.session.selectedSeats, lockId);
        console.error('Error during booking confirmation:', error);
        ctx.reply('Произошла ошибка при проверке доступности мест. Пожалуйста, попробуйте снова.');
    }
});


// Обработчики кнопок "Назад"
bot.action('back_to_section', async (ctx) => {
    if (ctx.session == undefined) {
        return ctx.reply('Введите /book для начала бронирования.');
    }
    ctx.session.step = BOOKING_STEPS.SELECT_SECTION;
    const sections = await getSections();

    if (sections.length === 0) {
        return ctx.reply('Нет доступных секций.');
    }

    const sectionButtons = sections.map((section) =>
        Markup.button.callback(section.name, `section_${section.name}`)
    );

    const selectedSeatsString = getSelectedSeatsString(ctx);
    try {
        await ctx.editMessageText(`Выбранные места:\n${selectedSeatsString}\nВыберите секцию:`, Markup.inlineKeyboard(sectionButtons, { columns: 2 }));
    }
    catch (error) {
        handleTelegramError(error, "back to section update text");
    }
    try {
        await ctx.answerCbQuery();
    } catch (error) {
        handleTelegramError(error, "answering callback query for back to section");
    }
});

// Add cancel_booking action
bot.action('cancel_booking', async (ctx) => {
    // Clear timer if exists
    if (ctx.session?.timerInterval) {
        clearInterval(ctx.session.timerInterval);
        if (ctx.session.timerMessageId) {
            try {
                await ctx.telegram.deleteMessage(ctx.chat!.id, ctx.session.timerMessageId);
            } catch (error) {
                console.error('Error deleting timer message:', error);
            }
        }
    }

    if (ctx.session) {
        // Release locks if they exist
        if (ctx.session.selectedSeats && ctx.session.lockId) {
            await releaseTemporaryLocks(ctx.session.selectedSeats, ctx.session.lockId);
        }
        
        ctx.session.selectedSeats = [];
        ctx.session.step = undefined;
    }
    try {
        await ctx.editMessageText('Бронирование отменено.');
    }
    catch (error) {
        handleTelegramError(error, "cancel booking update text");
    }
    try {
        await ctx.answerCbQuery();  // Important: Acknowledge the callback query
    } catch (error) {
        handleTelegramError(error, "answering callback query for cancel booking");
    }
});

bot.action(/back_to_row_(.+)/, async (ctx) => {
    const sectionName = ctx.match[1];
    if (!ctx.session) {
        return ctx.reply('Введите /book для начала бронирования.');
    }

    ctx.session.step = BOOKING_STEPS.SELECT_ROW;

    const rows = await getRows(sectionName);
    const rowButtons = rows.map((row) =>
        Markup.button.callback(`Ряд ${row.row_number} (${row.free_seats}/${row.total_seats})`, `row_${sectionName}_${row.row_number}`)
    );
    rowButtons.push(Markup.button.callback('Назад', 'back_to_section'));
    rowButtons.push(Markup.button.callback('Отмена', 'cancel_booking'));

    const selectedSeatsString = getSelectedSeatsString(ctx);
    try {
        await ctx.editMessageText(`Выбранные места:\n${selectedSeatsString}\n\nТеущий выбор:\nСекция ${sectionName}\nВыберите ряд:`, Markup.inlineKeyboard(rowButtons, { columns: 3 }));
    }
    catch (error) {
        handleTelegramError(error, "back to row update text");
    }
    try {
        await ctx.answerCbQuery();
    } catch (error) {
        handleTelegramError(error, "answering callback query for back to row");
    }
});

// Обработчик команды /mybookings
bot.command('mybookings', async (ctx) => {
    const client = await pool.connect();
    try {
        const { rows: bookings } = await client.query(
            `SELECT sections.name AS section_name, rows.row_number, seats.seat_number
       FROM seats
       JOIN rows ON rows.id = seats.row_id
       JOIN sections ON sections.id = rows.section_id
       WHERE seats.booked_by = (SELECT id FROM users WHERE telegram_id = $1);
      `,
            [ctx.from?.id]
        );

        if (bookings.length === 0) {
            ctx.reply('У вас нет активных броней.');
            return;
        }

        const message = bookings
            .map((b) => `Секция: ${b.section_name}, Ряд: ${b.row_number}, Место: ${b.seat_number}`)
            .join('\n');

        ctx.reply(`Ваши брони:\n${message}\nДля отмены брони введите /cancel.`);
    } catch (error) {
        console.error('Error fetching bookings:', error);
        ctx.reply('Произошла ошибка при получении ваших броней. Попробуйте позже.');
    } finally {
        client.release();
    }
});

// Обработчик команды /cancel
bot.command('cancel', async (ctx) => {
    const client = await pool.connect();
    try {
        const userId = (await client.query(`SELECT id FROM users WHERE telegram_id = $1`, [ctx.from?.id]))?.rows?.[0]?.id;

        if (!userId) {
            ctx.reply('У вас нет активных броней.');
            return;
        }

        ctx.session = { selectedSeats: [], step: 'cancel_seat' }; // Initialize session for cancellation

        const sections = await getCancellableSections(userId); // Get sections with bookable seats by this user


        if (sections.length === 0) {
            ctx.reply('У вас нет активных броней.');
            delete ctx.session.step;  //Clear session if no bookings
            return;
        }

        const sectionButtons = sections.map((section) =>
            Markup.button.callback(section.name, `cancel_section_${section.name}`)
        );


        ctx.reply('Выберите секцию для отмены бронирования:', Markup.inlineKeyboard(sectionButtons, { columns: 2 }));


    } catch (error) {
        console.error('Error fetching bookings for cancellation:', error);
        ctx.reply('Произошла ошибка при получении ваших броней. Попробуйте позже.');
        if (ctx.session != undefined)
            delete ctx.session.step;  //Clear session in case of error
    } finally {
        client.release();
    }
});


async function getCancellableSections(userId: number) {
    const client = await pool.connect();
    try {
        const { rows } = await client.query(
            `SELECT DISTINCT sections.name
             FROM seats
             JOIN rows ON seats.row_id = rows.id
             JOIN sections ON rows.section_id = sections.id
             WHERE seats.booked_by = $1`,
            [userId]
        );
        return rows;
    } finally {
        client.release();
    }
}


async function getCancellableRows(sectionName: string, ctx: TgContext) {
    const client = await pool.connect();
    try {
        const userId = (await client.query(`SELECT id FROM users WHERE telegram_id = $1`, [ctx.from?.id]))?.rows?.[0]?.id;
        const { rows } = await client.query(
            `SELECT DISTINCT rows.row_number
             FROM seats
             JOIN rows ON seats.row_id = rows.id
             JOIN sections ON rows.section_id = sections.id
             WHERE sections.name = $1 AND seats.booked_by = $2`,
            [sectionName, userId]
        );
        return rows;
    } finally {
        client.release();
    }
}


async function getCancellableSeats(sectionName: string, rowNumber: number, ctx: TgContext) {
    const client = await pool.connect();
    try {

        const userId = (await client.query(`SELECT id FROM users WHERE telegram_id = $1`, [ctx.from?.id]))?.rows?.[0]?.id;
        const { rows } = await client.query(
            `SELECT seats.seat_number
             FROM seats
             JOIN rows ON seats.row_id = rows.id
             JOIN sections ON rows.section_id = sections.id
             WHERE sections.name = $1
             AND rows.row_number = $2 AND seats.booked_by = $3
             ORDER BY seats.seat_number;`,
            [sectionName, rowNumber, userId]
        );
        return rows;
    } finally {
        client.release();
    }
}


bot.on('text', async (ctx) => {
    const client = await pool.connect();
    try {
        if (ctx.session?.step === BOOKING_STEPS.AWAITING_FULL_NAME) {
            ctx.session.fullName = ctx.message.text.trim();

            // Валидация ФИО (минимум 2 слова)
            if (ctx.session.fullName.split(/\s+/).length < 2) {
                ctx.reply('Пожалуйста, введите Фамилию и Имя целиком');
                return;
            }

            ctx.reply('Введите ваш номер телефона с кодом оператора в формате +375291111111:');
            ctx.session.step = BOOKING_STEPS.AWAITING_PHONE_NUMBER;
        } else if (ctx.session?.step === BOOKING_STEPS.AWAITING_PHONE_NUMBER) {
            const phoneNumber = ctx.message.text.trim();
            // Валидация номера телефона (простой пример, можно использовать более сложные регулярные выражения)
            if (!/^\+?\d{12}$/.test(phoneNumber)) {
                ctx.reply('Пожалуйста, введите корректный номер телефона (например, +375291111111).');
                return;
            }

            // Check if the phone number already exists, BUT EXCLUDE the current user
            const { rows: existingUser } = await client.query(
                'SELECT * FROM users WHERE phone_number = $1 AND telegram_id != $2',
                [phoneNumber, ctx.from?.id]
            );

            if (existingUser.length > 0) {
                ctx.reply('Этот номер телефона уже используется. Пожалуйста, введите другой номер.');
                return; // Stop further processing
            }

            // Clear booking timer
            if (ctx.session.timerInterval) {
                clearInterval(ctx.session.timerInterval);
                if (ctx.session.timerMessageId) {
                    try {
                        await ctx.telegram.deleteMessage(ctx.chat!.id, ctx.session.timerMessageId);
                    } catch (error) {
                        console.error('Error deleting timer message:', error);
                    }
                }
            }

            ctx.session.phoneNumber = phoneNumber;

            const { rows: userRows } = await client.query(
                `INSERT INTO users (full_name, phone_number, telegram_id) 
                VALUES ($1, $2, $3) 
                ON CONFLICT (telegram_id) DO UPDATE SET full_name = EXCLUDED.full_name, phone_number = EXCLUDED.phone_number
                RETURNING id;`,
                [ctx.session.fullName, ctx.session.phoneNumber, ctx.from?.id]
            );

            const userId = userRows[0].id;
            
            // Get the lock ID from the session or generate a new one
            const lockId = ctx.session.lockId || generateLockId(ctx);

            const bookedSeats: { section: string; row: number; seat: number }[] = [];
            const successfullyBookedSeats: { section: string; row: number; seat: number }[] = [];
            
            // Before proceeding to book seats, verify that our temporary locks are still valid
            const allLocksValid = await verifyTemporaryLocks(ctx.session.selectedSeats || [], lockId);
            
            if (!allLocksValid) {
                // Release any remaining locks
                await releaseTemporaryLocks(ctx.session.selectedSeats || [], lockId);
                ctx.reply('Извините, но некоторые из выбранных мест были забронированы другим пользователем. Пожалуйста, начните бронирование заново.');
                ctx.session = { selectedSeats: [], step: BOOKING_STEPS.SELECT_SECTION };
                return startBooking(ctx);
            }

            for (const seat of ctx.session.selectedSeats || []) {
                const { rows: seatCheck } = await client.query(
                    `SELECT is_booked FROM seats 
                     JOIN rows ON seats.row_id = rows.id
                     JOIN sections ON rows.section_id = sections.id
                     WHERE sections.name = $1
                     AND rows.row_number = $2
                     AND seats.seat_number = $3
                     AND is_booked = FALSE;`, // Проверяем, что место все еще свободно
                    [seat.section, seat.row, seat.seat]
                );

                if (seatCheck.length === 0) {
                    bookedSeats.push(seat);
                } else {
                    successfullyBookedSeats.push(seat);
                }
            }

            // Release all temporary locks now that we're proceeding with actual booking
            await releaseTemporaryLocks(ctx.session.selectedSeats || [], lockId);

            if (bookedSeats.length > 0) {
                const bookedSeatsString = bookedSeats.map(s => `Место ${s.seat} в секции ${s.section}, ряд ${s.row}`).join('\n');
                ctx.reply(`${bookedSeatsString} уже забронировано. Пожалуйста, выберите другое место.`);
            }

            if (successfullyBookedSeats.length > 0) {
                try {
                   const successful = await updateSeatsAndSheet(successfullyBookedSeats, userId, true, ctx);
                   // Update cache after booking
                   await refreshUsersWithTwoSeatsCache();
                   
                   if (successful) {
                       // Send a rich confirmation message
                       const confirmationMessage = createBookingConfirmation(
                           ctx.session.fullName,
                           ctx.session.phoneNumber,
                           successfullyBookedSeats
                       );
                       
                       // Send with markdown formatting
                       await ctx.replyWithMarkdown(confirmationMessage);
                   }
                   
                   ctx.session = {}; // Clear session after successful booking
                }
                catch (error) {
                    // Error is already handled in updateSeatsAndSheet
                }
            }

           if(successfullyBookedSeats.length === 0 && bookedSeats.length > 0) {
               ctx.session.selectedSeats = []; // Clear the selected seats if all were booked
               ctx.session.step = BOOKING_STEPS.SELECT_SECTION;
               startBooking(ctx);
           }
        }
        else {
            ctx.reply('Используйте команду /book для начала бронирования или /mybookings для просмотра броней.');
        }
    } catch (error) {
        console.error('Error processing cancellation:', error);
        ctx.reply('Произошла ошибка при бронировании. Попробуйте снова.');
        
        // Release locks if they exist
        if (ctx.session?.selectedSeats && ctx.session?.lockId) {
            await releaseTemporaryLocks(ctx.session.selectedSeats, ctx.session.lockId);
        }
        
        // Clear timer if exists
        if (ctx.session?.timerInterval) {
            clearInterval(ctx.session.timerInterval);
        }
    } finally {
        client.release();
    }
});

// Update checkSpreadsheetChanges to use the new retry result format
async function checkSpreadsheetChanges() {
  try {
    const retryResult = await withRetry(async () => {
      await doc.loadInfo();
      const client = await pool.connect();
      
      try {
        const { rows: dbSections } = await client.query(`SELECT DISTINCT name FROM sections`);
        const sectionNames = dbSections.map(section => section.name);
        
        // Process each section sequentially to avoid hitting rate limits
        for (const sectionName of sectionNames) {
          const sheet = doc.sheetsByTitle[sectionName];
          if (!sheet) continue;
          
          await sheet.loadCells('A1:AH30');
          
          // Get database seats for this section only
          const { rows: dbSeats } = await client.query(
            `SELECT rows.row_number, seats.seat_number, seats.is_booked
              FROM seats
              JOIN rows ON seats.row_id = rows.id
              JOIN sections ON rows.section_id = sections.id
              WHERE sections.name = $1`,
            [sectionName]
          );
          
          for (const dbSeat of dbSeats) {
            const colLetter = numToColLetter(dbSeat.seat_number);
            const cell = sheet.getCellByA1(`${colLetter}${dbSeat.row_number}`);
            
            let isBookedInSpreadsheet = null;
            if (typeof cell.value === 'boolean') {
              isBookedInSpreadsheet = cell.value;
            } else if (cell.value === "TRUE" || cell.value === "FALSE") {
              isBookedInSpreadsheet = cell.value === "TRUE";
            }
            
            if (isBookedInSpreadsheet !== null) {
              const isBookedInDb = dbSeat.is_booked;
              
              if (isBookedInSpreadsheet && !isBookedInDb) {
                await handleRedCell(sectionName, dbSeat.row_number, dbSeat.seat_number, client);
              } else if (!isBookedInSpreadsheet && isBookedInDb) {
                await handleGreenCell(sectionName, dbSeat.row_number, dbSeat.seat_number, client);
              }
            }
          }
          
          // Add a delay between sections to avoid rate limits
          await new Promise(resolve => setTimeout(resolve, 300));
        }
      } finally {
        client.release();
      }
      
      return true;
    });
    
    if (!retryResult.success) {
      console.warn('checkSpreadsheetChanges failed after retries. Will try again on next interval.');
    }
  } catch (error) {
    console.error('Ошибка при проверке изменений:', error);
  }
}


async function handleRedCell(sectionName: string, rowNumber: number, seatNumber: number, client: any): Promise<void> {
    try {

        // Забронировать место в БД, если оно не забронировано
        const { rowCount } = await client.query(
            `UPDATE seats SET is_booked = TRUE
             WHERE row_id = (SELECT id FROM rows WHERE section_id = (SELECT id FROM sections WHERE name = $1) AND row_number = $2)
             AND seat_number = $3 AND is_booked = FALSE
             RETURNING *;`,
            [sectionName, rowNumber, seatNumber]
        );

    }
    catch (error) {
        console.log(error);
    }
}

async function handleGreenCell(sectionName: string, rowNumber: number, seatNumber: number, client: any): Promise<void> {
    try {

        // Отменить бронь и освободить место
        const { rows: bookingInfo } = await client.query(
            `UPDATE seats SET is_booked = FALSE, booked_by = NULL
             WHERE row_id = (SELECT id FROM rows WHERE section_id = (SELECT id FROM sections WHERE name = $1) AND row_number = $2)
             AND seat_number = $3
             RETURNING booked_by;`,
            [sectionName, rowNumber, seatNumber]
        );

        const bookedByUserId = bookingInfo[0]?.booked_by;
        if (bookedByUserId) {
            // Уведомить пользователя об отмене брони (если есть booked_by)
            const { rows: telegramIdRows } = await client.query(`SELECT telegram_id FROM users WHERE id = $1`, [bookedByUserId]);
            const telegramId = telegramIdRows[0]?.telegram_id;
            if (telegramId) {
                try {
                    await bot.telegram.sendMessage(telegramId, `Ваша бронь на место ${seatNumber} в секции ${sectionName}, ряд ${rowNumber} была отменена.`);
                } catch (telegramError) {
                    console.error('Ошибка при отправке сообщения в Telegram:', telegramError);
                }
            }
        }
    }
    catch (error) {
        console.log(error);
    }
}

function numToColLetter(num: number) {
    let colLetter = "";
    while (num > 0) {
        let remainder = (num - 1) % 26;
        colLetter = String.fromCharCode(65 + remainder) + colLetter;
        num = Math.floor((num - 1) / 26);
    }
    return colLetter;
}

// Modify the setInterval calls to use longer intervals
setInterval(checkSpreadsheetChanges, 60 * 1000); // Changed from 60 * 1000
setInterval(fetchDataAndWriteToSheet, 60 * 1000); // Changed from 60 * 1000

// Запуск бота
bot.launch();

// Обработка завершения работы
process.once('SIGINT', () => bot.stop('SIGINT'));
process.once('SIGTERM', () => bot.stop('SIGTERM'));

// Restore the fetchDataAndWriteToSheet function
async function fetchDataAndWriteToSheet() {
    const client = await pool.connect();
    try {
        const { rows: data } = await client.query(`
            SELECT
                u.full_name as "ФИО",
                u.phone_number as "Телефон",
                s.name as "Секция",
                r.row_number as "Ряд",
                json_agg(st.seat_number ORDER BY st.seat_number) AS "Место"
            FROM
                users u
            LEFT JOIN
                seats st ON u.id = st.booked_by
            LEFT JOIN
                rows r ON st.row_id = r.id
            LEFT JOIN
                sections s ON r.section_id = s.id
            WHERE st.booked_by IS NOT NULL
            GROUP BY
                u.id, u.full_name, u.phone_number, s.name, r.row_number
            ORDER BY u.id, s.name, r.row_number;
        `);

        await writeToGoogleSheet(data);

    } catch (error) {
        console.error('Error fetching data or writing to sheet:', error);
    } finally {
        client.release();
    }
}

// Update writeToGoogleSheet to use the new retry result format
async function writeToGoogleSheet(data: any[]) {
  try {
    const retryResult = await withRetry(async () => {
      await bookingsDoc.loadInfo();
      const sheet = await ensureSheetExistsInDoc(bookingsDoc, booking_sheet_name!);
      await sheet.loadCells();
      
      const lastRow = sheet.rowCount;
      
      await sheet.clear(`A2:E${lastRow}`);
      
      await sheet.setHeaderRow(['ФИО', 'Телефон', 'Секции', 'Ряды', 'Места', 'Оплата']);
      
      const rowsToAdd = [];
      let previousFio = "";
      let previousPhone = "";
      
      for (const item of data) {
        const fioToAdd = item.ФИО !== previousFio ? item.ФИО : null;
        const phoneToAdd = item.Телефон !== previousPhone ? item.Телефон : null;
        
        const seatsArray = Array.isArray(item.Место) ? item.Место : [item.Место];
        
        rowsToAdd.push([fioToAdd, phoneToAdd, item.Секция, `'` + item.Ряд.toString(), `'` + seatsArray.join(', ')]);
        previousFio = item.ФИО;
        previousPhone = item.Телефон;
      }
      
      if (rowsToAdd.length > 0)
        await sheet.addRows(rowsToAdd);
      
      return true;
    });
    
    if (!retryResult.success) {
      console.warn('Failed to write to Google Sheet after retries. Will try again on next interval.');
    }
  } catch (error) {
    console.error('Error writing to Google Sheet:', error);
  }
}

async function ensureSheetExistsInDoc(doc: GoogleSpreadsheet, title: string): Promise<GoogleSpreadsheetWorksheet> {
    try {
        let sheet = doc.sheetsByTitle[title];
        if (!sheet) {
            sheet = await doc.addSheet({ title });
        }
        return sheet;
    } catch (error) {
        console.error(`Error creating sheet "${title}" in document:`, error);
        throw error;
    }
}

// Add these utility functions for temporary seat locking

// Create a lock ID for current user session
function generateLockId(ctx: TgContext): string {
    return `user_${ctx.from?.id}_${Date.now()}`;
}

// Create temporary locks for seats
async function createTemporaryLocks(seats: { section: string; row: number; seat: number }[], lockId: string): Promise<boolean> {
    const client = await pool.connect();
    try {
        await client.query('BEGIN');
        
        for (const seat of seats) {
            // Check if seat is already booked in main seats table
            const { rows: bookedCheck } = await client.query(
                `SELECT 1 FROM seats 
                 JOIN rows ON seats.row_id = rows.id 
                 JOIN sections ON rows.section_id = sections.id 
                 WHERE sections.name = $1 AND rows.row_number = $2 AND seats.seat_number = $3 AND seats.is_booked = TRUE`,
                [seat.section, seat.row, seat.seat]
            );
            
            if (bookedCheck.length > 0) {
                await client.query('ROLLBACK');
                return false; // Seat is already booked
            }
            
            // Check if seat has a temporary lock by someone else
            const { rows: lockCheck } = await client.query(
                `SELECT locked_by FROM temp_locks 
                 WHERE section_name = $1 AND row_number = $2 AND seat_number = $3 
                 AND created_at > NOW() - INTERVAL '2 minutes'`,
                [seat.section, seat.row, seat.seat]
            );
            
            if (lockCheck.length > 0 && lockCheck[0].locked_by !== lockId) {
                await client.query('ROLLBACK');
                return false; // Seat is locked by someone else
            }
            
            // Create or update lock
            await client.query(
                `INSERT INTO temp_locks (section_name, row_number, seat_number, locked_by, created_at)
                 VALUES ($1, $2, $3, $4, NOW())
                 ON CONFLICT (section_name, row_number, seat_number) 
                 DO UPDATE SET locked_by = $4, created_at = NOW()`,
                [seat.section, seat.row, seat.seat, lockId]
            );
        }
        
        await client.query('COMMIT');
        return true;
    } catch (error) {
        console.error('Error creating temporary locks:', error);
        await client.query('ROLLBACK');
        return false;
    } finally {
        client.release();
    }
}

// Release temporary locks
async function releaseTemporaryLocks(seats: { section: string; row: number; seat: number }[], lockId: string): Promise<void> {
    if (seats.length === 0) return;
    
    const client = await pool.connect();
    try {
        // For each seat, issue a separate DELETE query
        // This is simpler and more reliable than building a complex query
        for (const seat of seats) {
            await client.query(
                `DELETE FROM temp_locks 
                 WHERE locked_by = $1 
                 AND section_name = $2 
                 AND row_number = $3 
                 AND seat_number = $4`,
                [lockId, seat.section, seat.row, seat.seat]
            );
        }
    } catch (error) {
        console.error('Error releasing temporary locks:', error);
    } finally {
        client.release();
    }
}

// Cleanup expired temporary locks (call this periodically)
async function cleanupExpiredLocks(): Promise<void> {
    const client = await pool.connect();
    try {
        await client.query(
            `DELETE FROM temp_locks WHERE created_at < NOW() - INTERVAL '2 minutes'`
        );
    } catch (error) {
        console.error('Error cleaning up expired locks:', error);
    } finally {
        client.release();
    }
}

// Set up a periodic cleanup of expired locks
setInterval(cleanupExpiredLocks, 60 * 1000); // Run every minute

// Add a function to verify locks are still valid
async function verifyTemporaryLocks(seats: { section: string; row: number; seat: number }[], lockId: string): Promise<boolean> {
    const client = await pool.connect();
    try {
        for (const seat of seats) {
            // Check if seat is already booked
            const { rows: bookedCheck } = await client.query(
                `SELECT 1 FROM seats 
                 JOIN rows ON seats.row_id = rows.id 
                 JOIN sections ON rows.section_id = sections.id 
                 WHERE sections.name = $1 AND rows.row_number = $2 AND seats.seat_number = $3 AND seats.is_booked = TRUE`,
                [seat.section, seat.row, seat.seat]
            );
            
            if (bookedCheck.length > 0) {
                return false; // Seat is already booked
            }
            
            // Check if our lock is still valid
            const { rows: lockCheck } = await client.query(
                `SELECT 1 FROM temp_locks 
                 WHERE section_name = $1 AND row_number = $2 AND seat_number = $3 
                 AND locked_by = $4 AND created_at > NOW() - INTERVAL '2 minutes'`,
                [seat.section, seat.row, seat.seat, lockId]
            );
            
            if (lockCheck.length === 0) {
                return false; // Our lock is gone or expired
            }
        }
        
        return true; // All locks are valid
    } catch (error) {
        console.error('Error verifying temporary locks:', error);
        return false;
    } finally {
        client.release();
    }
}
