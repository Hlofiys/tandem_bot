// –ò–º–ø–æ—Ä—Ç –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã—Ö –±–∏–±–ª–∏–æ—Ç–µ–∫
import { Telegraf, Markup, Context, session } from 'telegraf';
import { Pool } from 'pg';
import { BotCommand } from 'telegraf/types';
import { GoogleSpreadsheet, GoogleSpreadsheetWorksheet } from 'google-spreadsheet';
import { JWT } from 'google-auth-library';

interface SessionData {
    step?: string;
    userId?: number;
    selectedRow?: number;
    selectedSection?: string;
    selectedSeat?: number;
    selectedSeats?: { section: string; row: number; seat: number }[];
    fullName?: string;
    phoneNumber?: string;
}

interface TgContext extends Context {
    session?: SessionData;
}
const MAX_SEATS_PER_USER = 4;
const booking_sheet_name = process.env.BOOKING_SHEET;
if (booking_sheet_name == undefined) {
    console.error('Booking sheet name is not defined');
}
const token = process.env.BOT_TOKEN;
if (token == undefined) {
    console.error('Token is not defined');
}
// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Telegram Bot API
const bot = new Telegraf<TgContext>(token!);
bot.use(session());

// Define the bot commands
const commands: BotCommand[] = [
    { command: 'start', description: '–ó–∞–ø—É—Å—Ç–∏—Ç—å –±–æ—Ç–∞' },
    { command: 'book', description: '–ù–∞—á–∞—Ç—å –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ' },
    { command: 'mybookings', description: '–ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å –∑–∞–±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –º–µ—Å—Ç–∞' },
    { command: 'cancel', description: '–û—Ç–º–µ–Ω–∏—Ç—å –±—Ä–æ–Ω—å' },
];

// Set the bot commands when the bot starts
bot.telegram.setMyCommands(commands)
    .then(() => {
        console.log('Bot commands set successfully.');
    })
    .catch((error) => {
        console.error('Error setting bot commands:', error);
    });

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö PostgreSQL
const pool = new Pool({
    user: 'postgres',
    host: 'tandem_db',
    database: process.env.DB_NAME ?? 'bot',
    password: 'postgres',
    port: 5432,
});

// –°–æ–∑–¥–∞–Ω–∏–µ —Ç–∞–±–ª–∏—Ü –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö (–≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è –æ–¥–∏–Ω —Ä–∞–∑)
(async () => {
    const client = await pool.connect();
    try {
        await client.query(`
      CREATE TABLE IF NOT EXISTS sections (
        id SERIAL PRIMARY KEY,
        name TEXT NOT NULL
      );

      CREATE TABLE IF NOT EXISTS rows (
        id SERIAL PRIMARY KEY,
        section_id INTEGER NOT NULL REFERENCES sections(id),
        row_number INTEGER NOT NULL
      );

      CREATE TABLE IF NOT EXISTS users (
        id SERIAL PRIMARY KEY,
        full_name TEXT NOT NULL,
        phone_number TEXT NOT NULL UNIQUE,
        telegram_id BIGINT NOT NULL UNIQUE
      );

      CREATE TABLE IF NOT EXISTS seats (
        id SERIAL PRIMARY KEY,
        row_id INTEGER NOT NULL REFERENCES rows(id),
        seat_number INTEGER NOT NULL,
        is_booked BOOLEAN DEFAULT FALSE,
        booked_by INTEGER REFERENCES users(id)
      );

      CREATE INDEX IF NOT EXISTS users_telegram_id ON users (telegram_id);
    `);
    } catch (error) {
        console.error('Error creating tables:', error);
    } finally {
        client.release();
    }
})();

const serviceAccountAuth = new JWT({
    // env var values here are copied from service account credentials generated by google
    // see "Authentication" section in docs for more info
    email: process.env.GOOGLE_SERVICE_ACCOUNT_EMAIL,
    key: process.env.GOOGLE_PRIVATE_KEY?.replace(/\\n/g, '\n'),
    scopes: ['https://www.googleapis.com/auth/spreadsheets'],
});


if (process.env.GOOGLE_SHEET_ID == undefined)
    console.error('Define google sheet id')

// Google Sheets configuration
const doc = new GoogleSpreadsheet(process.env.GOOGLE_SHEET_ID!, serviceAccountAuth);
const bookingsDoc = new GoogleSpreadsheet(process.env.GOOGLE_SHEET_BOOKINGS_ID!, serviceAccountAuth);

// –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /start
bot.start(async (ctx) => {
    ctx.reply(`–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –≤ —Å–∏—Å—Ç–µ–º—É –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è –º–µ—Å—Ç –Ω–∞ –ó–û–ö 2025 –≤ ${process.env.EVENT_TIME ?? '12:30'}. –í–≤–µ–¥–∏—Ç–µ /book –¥–ª—è –Ω–∞—á–∞–ª–∞ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è.`);
});

// –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /book
const BOOKING_STEPS = {
    SELECT_SECTION: 'select_section',
    SELECT_ROW: 'select_row',
    SELECT_SEAT: 'select_seat',
    CONFIRM: 'confirm',
    AWAITING_FULL_NAME: 'awaiting_full_name',
    AWAITING_PHONE_NUMBER: 'awaiting_phone_number',
};

async function startBooking(ctx: TgContext) {
    ctx.session = { selectedSeats: [], step: BOOKING_STEPS.SELECT_SECTION };
    const sections = await getSections();

    if (sections.length === 0) {
        return ctx.reply('–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Å–µ–∫—Ü–∏–π.');
    }

    const sectionButtons = sections.map((section) =>
        Markup.button.callback(section.name, `section_${section.name}`)
    );

    return ctx.reply('–í—ã–±–µ—Ä–∏—Ç–µ —Å–µ–∫—Ü–∏—é:', Markup.inlineKeyboard(sectionButtons, { columns: 2 }));
}

// –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /book
bot.command('book', startBooking);


bot.action(/^cancel_section_(.+)/, async (ctx) => {
    const sectionName = ctx.match[1];
    if (ctx.session == undefined) {
        return;
    }
    ctx.session.selectedSection = sectionName;
    // Get cancellable rows for this user in this section
    const rows = await getCancellableRows(sectionName, ctx);
    const sectionButtons = rows.map((row) =>
        Markup.button.callback(`–†—è–¥ ${row.row_number}`, `cancel_row_${sectionName}_${row.row_number}`)
    );
    sectionButtons.push(Markup.button.callback('–û—Ç–º–µ–Ω–∞', 'cancel_booking'));

    ctx.editMessageText(`–í—ã–±–µ—Ä–∏—Ç–µ —Ä—è–¥ –¥–ª—è –æ—Ç–º–µ–Ω—ã (–°–µ–∫—Ü–∏—è ${sectionName}):`, Markup.inlineKeyboard(sectionButtons, { columns: 3 }));
});

bot.action(/^cancel_row_(.+)_(.+)/, async (ctx) => {
    const sectionName = ctx.match[1];
    const rowNumber = parseInt(ctx.match[2], 10);
    if (ctx.session == undefined) {
        return;
    }
    ctx.session.selectedRow = rowNumber;


    const seats = await getCancellableSeats(sectionName, rowNumber, ctx);

    const selectedSeats = ctx.session?.selectedSeats || [];

    const rowButtons = seats.map((seat) => {
        let label = `–ú–µ—Å—Ç–æ ${seat.seat_number}`;
        if (selectedSeats.some(s => s.section === sectionName && s.row === rowNumber && s.seat === seat.seat_number)) {
            label += " ‚úÖ"; // Mark selected seats
        }
        return Markup.button.callback(label, `cancel_seat_${sectionName}_${rowNumber}_${seat.seat_number}`);
    });

    rowButtons.push(Markup.button.callback('–ù–∞–∑–∞–¥', `cancel_back_to_row_${sectionName}`));
    if (selectedSeats.length > 0) {
        rowButtons.push(Markup.button.callback('–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å –æ—Ç–º–µ–Ω—É', 'confirm_cancellation'));
    }
    rowButtons.push(Markup.button.callback('–û—Ç–º–µ–Ω–∞', 'cancel_booking'));

    ctx.editMessageText(`–í—ã–±–µ—Ä–∏—Ç–µ –º–µ—Å—Ç–∞ –¥–ª—è –æ—Ç–º–µ–Ω—ã (–°–µ–∫—Ü–∏—è ${sectionName}, –†—è–¥ ${rowNumber}):`, Markup.inlineKeyboard(rowButtons, { columns: 3 }));
});


bot.action(/cancel_seat_(.+)_(.+)_(.+)/, async (ctx) => {
    const [sectionName, rowNumberStr, seatNumberStr] = ctx.match.slice(1);
    const rowNumber = parseInt(rowNumberStr, 10);
    const seatNumber = parseInt(seatNumberStr, 10);

    if (ctx.session == undefined) {
        return;
    }

    ctx.session.selectedSeats = ctx.session.selectedSeats || [];

    const seatInfo = { section: sectionName, row: rowNumber, seat: seatNumber };

    const existingSeatIndex = ctx.session.selectedSeats.findIndex(
        (s) => s.section === sectionName && s.row === rowNumber && s.seat === seatNumber
    );

    if (existingSeatIndex > -1) {
        ctx.session.selectedSeats.splice(existingSeatIndex, 1); // Remove if already selected
        ctx.answerCbQuery(`–ú–µ—Å—Ç–æ ${seatNumber} —Å–Ω—è—Ç–æ —Å –æ—Ç–º–µ–Ω—ã.`);
    } else {
        ctx.session.selectedSeats.push(seatInfo); // Add to selected seats
        ctx.answerCbQuery(`–ú–µ—Å—Ç–æ ${seatNumber} –¥–æ–±–∞–≤–ª–µ–Ω–æ –∫ –æ—Ç–º–µ–Ω–µ.`);
    }

    // Re-render the seats buttons with updated selection
    const seats = await getCancellableSeats(sectionName, rowNumber, ctx);
    const selectedSeats = ctx.session?.selectedSeats || [];

    const rowButtons = seats.map((seat) => {
        let label = `–ú–µ—Å—Ç–æ ${seat.seat_number}`;
        if (selectedSeats.some(s => s.section === sectionName && s.row === rowNumber && s.seat === seat.seat_number)) {
            label += " ‚úÖ"; // Mark selected seats
        }
        return Markup.button.callback(label, `cancel_seat_${sectionName}_${rowNumber}_${seat.seat_number}`);
    });

    rowButtons.push(Markup.button.callback('–ù–∞–∑–∞–¥', `cancel_back_to_row_${sectionName}`));
    if (selectedSeats.length > 0) {
        rowButtons.push(Markup.button.callback('–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å –æ—Ç–º–µ–Ω—É', 'confirm_cancellation'));
    }
    rowButtons.push(Markup.button.callback('–û—Ç–º–µ–Ω–∞', 'cancel_booking'));

    ctx.editMessageText(`–í—ã–±–µ—Ä–∏—Ç–µ –º–µ—Å—Ç–∞ –¥–ª—è –æ—Ç–º–µ–Ω—ã (–°–µ–∫—Ü–∏—è ${sectionName}, –†—è–¥ ${rowNumber}):`, Markup.inlineKeyboard(rowButtons, { columns: 3 }));

});

bot.action('confirm_cancellation', async (ctx) => {
    if (!ctx.session || !ctx.session.selectedSeats || ctx.session.selectedSeats.length === 0) {
        return ctx.reply('–í—ã –Ω–µ –≤—ã–±—Ä–∞–ª–∏ –º–µ—Å—Ç–∞ –¥–ª—è –æ—Ç–º–µ–Ω—ã.');
    }

    await ctx.deleteMessage();

    const client = await pool.connect();
    try {
        const userId = (await client.query(`SELECT id FROM users WHERE telegram_id = $1`, [ctx.from?.id]))?.rows?.[0]?.id;

        if (!userId) {
            ctx.reply('–£ –≤–∞—Å –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –±—Ä–æ–Ω–µ–π.');
            return;
        }

        try {
            await updateSeatsAndSheet(ctx.session.selectedSeats, userId, false, ctx);
            ctx.reply(`${ctx.session.selectedSeats.length} –º–µ—Å—Ç(–∞) —É—Å–ø–µ—à–Ω–æ –æ—Ç–º–µ–Ω–µ–Ω–æ.`);
            ctx.session.step = undefined; // Clear the session after cancellation
            ctx.session.selectedSeats = []; // Clear selected seats
        } catch (error) {
            // Error is already handled in updateSeatsAndSheet
        }

    } catch (error) {
        console.error('Error during initial phase of seat cancellation (fetching userId):', error);
        ctx.reply('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–º–µ–Ω–µ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.');

    } finally {
        client.release();
        await ctx.answerCbQuery();
    }
});

// Action handler for 'back' button during cancellation
bot.action(/^cancel_back_to_row_(.+)/, async (ctx) => {
    const sectionName = ctx.match[1];
    if (ctx.session) {
        ctx.session.selectedRow = undefined; // Reset selected row in session
        const rows = await getCancellableRows(sectionName, ctx);
        const rowButtons = rows.map((row) =>
            Markup.button.callback(`–†—è–¥ ${row.row_number}`, `cancel_row_${sectionName}_${row.row_number}`)
        );


        rowButtons.push(Markup.button.callback('–û—Ç–º–µ–Ω–∞', 'cancel_booking'));
        ctx.editMessageText(`–í—ã–±–µ—Ä–∏—Ç–µ —Ä—è–¥ –¥–ª—è –æ—Ç–º–µ–Ω—ã (–°–µ–∫—Ü–∏—è ${sectionName}):`, Markup.inlineKeyboard(rowButtons, { columns: 3 }));
    }
});

// –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∫–Ω–æ–ø–æ–∫ –≤—ã–±–æ—Ä–∞ —Å–µ–∫—Ü–∏–∏, —Ä—è–¥–∞ –∏ –º–µ—Å—Ç–∞
bot.action(/section_(.+)/, async (ctx) => {
    const sectionName = ctx.match[1];
    if (ctx.session == undefined) {
        return ctx.reply('–í–≤–µ–¥–∏—Ç–µ /book –¥–ª—è –Ω–∞—á–∞–ª–∞ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è.');
    }
    ctx.session.selectedSection = sectionName;
    ctx.session.step = BOOKING_STEPS.SELECT_ROW;

    const rows = await getRows(sectionName);
    const sectionButtons = rows.map((row) =>
        Markup.button.callback(`–†—è–¥ ${row.row_number} (${row.free_seats}/${row.total_seats})`, `row_${sectionName}_${row.row_number}`)
    );
    sectionButtons.push(Markup.button.callback('–ù–∞–∑–∞–¥', 'back_to_section'));
    sectionButtons.push(Markup.button.callback('–û—Ç–º–µ–Ω–∞', 'cancel_booking')); // Add cancel button

    const selectedSeatsString = getSelectedSeatsString(ctx);
    return ctx.editMessageText(`–í—ã–±—Ä–∞–Ω–Ω—ã–µ –º–µ—Å—Ç–∞:\n${selectedSeatsString}\n\n–¢–µ–∫—É—â–∏–π –≤—ã–±–æ—Ä:\nC–µ–∫—Ü–∏—è ${sectionName}\n–í—ã–±–µ—Ä–∏—Ç–µ —Ä—è–¥:`, Markup.inlineKeyboard(sectionButtons, { columns: 3 }));
});

bot.action(/row_(.+)_(.+)/, async (ctx) => {
    const sectionName = (ctx.match[1]);
    const rowNumber = (ctx.match[2]);
    if (ctx.session == undefined) {
        return ctx.reply('–í–≤–µ–¥–∏—Ç–µ /book –¥–ª—è –Ω–∞—á–∞–ª–∞ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è.');
    }
    ctx.session.selectedRow = parseInt(rowNumber, 10);
    ctx.session.step = BOOKING_STEPS.SELECT_SEAT;
    const seats = await getSeats(sectionName, parseInt(rowNumber, 10), ctx);
    const rowButtons = seats.map((seat) => { // Use seats with isBookedByUser
        let label = `–ú–µ—Å—Ç–æ ${seat.seat_number}`;
        if (seat.isSelected) {
            label += " ‚úÖ";
        } else if (seat.isBookedByUser) {
            label += " üë§";
        }
        else if (seat.isBooked) {
            label += ' ‚ùå';
        }
        return Markup.button.callback(label, `seat_${sectionName}_${parseInt(rowNumber, 10)}_${seat.seat_number}`);
    });
    rowButtons.push(Markup.button.callback('–ù–∞–∑–∞–¥', `back_to_row_${sectionName}`));
    rowButtons.push(Markup.button.callback('–û—Ç–º–µ–Ω–∞', 'cancel_booking')); // Add cancel button
    if (ctx.session.selectedSeats != undefined && ctx.session.selectedSeats.length! > 0) {
        rowButtons.push(Markup.button.callback('–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å', 'confirm_booking'));
    }

    const selectedSeatsString = getSelectedSeatsString(ctx);
    ctx.editMessageText(`–í—ã–±—Ä–∞–Ω–Ω—ã–µ –º–µ—Å—Ç–∞:\n${selectedSeatsString}\n\n–¢–µ–∫—É—â–∏–π –≤—ã–±–æ—Ä:\nC–µ–∫—Ü–∏—è ${sectionName}, –†—è–¥ ${rowNumber}\n–í—ã–±–µ—Ä–∏—Ç–µ –º–µ—Å—Ç–æ:`, Markup.inlineKeyboard(rowButtons, { columns: 3 }));
});


bot.action(/seat_(.+)_(.+)_(.+)/, async (ctx) => {
    const [sectionName, rowNumber, seatNumber] = ctx.match.slice(1);
    if (!ctx.session || !ctx.session.selectedSeats) {
        return ctx.reply('–í–≤–µ–¥–∏—Ç–µ /book –¥–ª—è –Ω–∞—á–∞–ª–∞ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è.');
    }

    const seatInfo = {
        section: sectionName,
        row: parseInt(rowNumber, 10),
        seat: parseInt(seatNumber, 10),
    };

    const existingSeatIndex = ctx.session.selectedSeats.findIndex(
        (s) => s.section === seatInfo.section && s.row === seatInfo.row && s.seat === seatInfo.seat
    );

    var seats = await getSeats(sectionName, parseInt(rowNumber, 10), ctx);
    const selectedSeat = seats.find(seat => seat.seat_number === parseInt(seatNumber)); // –ù–∞—Ö–æ–¥–∏–º selectedSeat

    if (existingSeatIndex > -1) {
        ctx.session.selectedSeats.splice(existingSeatIndex, 1);
        ctx.answerCbQuery(`–ú–µ—Å—Ç–æ ${seatNumber} —Å–Ω—è—Ç–æ —Å –±—Ä–æ–Ω–∏.`);
    } else if (!selectedSeat?.isBookedByUser && !selectedSeat?.isBooked) { // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ undefined –∏ isBookedByUser
        // Check if adding this seat exceeds the limit
        if (ctx.session.selectedSeats.length >= MAX_SEATS_PER_USER) {
            ctx.answerCbQuery(`–í—ã –º–æ–∂–µ—Ç–µ –∑–∞–±—Ä–æ–Ω–∏—Ä–æ–≤–∞—Ç—å –º–∞–∫—Å–∏–º—É–º ${MAX_SEATS_PER_USER} –º–µ—Å—Ç–∞.`);
            return;
        }


        const client = await pool.connect();

        try {
            const userBookings = await client.query(
                `SELECT COUNT(*) FROM seats WHERE booked_by = (SELECT id FROM users WHERE telegram_id = $1)`,
                [ctx.from.id]
            )


            if (parseInt(userBookings.rows[0].count) + ctx.session.selectedSeats.length >= MAX_SEATS_PER_USER) {
                ctx.answerCbQuery(`–í—ã –º–æ–∂–µ—Ç–µ –∑–∞–±—Ä–æ–Ω–∏—Ä–æ–≤–∞—Ç—å –º–∞–∫—Å–∏–º—É–º ${MAX_SEATS_PER_USER} –º–µ—Å—Ç–∞.`);
                return;
            }


        } catch (error) {
            console.log("Failed to get user bookings")
        } finally {
            client.release();
        }

        ctx.session.selectedSeats.push(seatInfo);
        ctx.answerCbQuery(`–ú–µ—Å—Ç–æ ${seatNumber} –¥–æ–±–∞–≤–ª–µ–Ω–æ –∫ –±—Ä–æ–Ω–∏.`);
    } else if (selectedSeat?.isBookedByUser) {
        ctx.answerCbQuery('–≠—Ç–æ –º–µ—Å—Ç–æ —É–∂–µ –∑–∞–±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–æ –≤–∞–º–∏.');
        return;
    }
    else {
        ctx.answerCbQuery('–≠—Ç–æ –º–µ—Å—Ç–æ —É–∂–µ –∑–∞–Ω—è—Ç–æ.');
        return;
    }

    seats = await getSeats(sectionName, parseInt(rowNumber, 10), ctx);

    const seatButtons = seats.map((seat) => {
        let label = `–ú–µ—Å—Ç–æ ${seat.seat_number}`;
        if (seat.isSelected) {
            label += ' ‚úÖ';
        } else if (seat.isBookedByUser) {
            label += ' üë§';
        }
        else if (seat.isBooked) {
            label += ' ‚ùå';
        }
        return Markup.button.callback(label, `seat_${sectionName}_${parseInt(rowNumber, 10)}_${seat.seat_number}`);
    });

    seatButtons.push(Markup.button.callback('–ù–∞–∑–∞–¥', `back_to_row_${sectionName}`));
    seatButtons.push(Markup.button.callback('–û—Ç–º–µ–Ω–∞', 'cancel_booking'));
    if (ctx.session.selectedSeats.length > 0) {
        seatButtons.push(Markup.button.callback('–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å', 'confirm_booking'));
    }

    const selectedSeatsString = getSelectedSeatsString(ctx);

    try {
        //  –û–±—ä–µ–¥–∏–Ω—è–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞ –∏ –∫–Ω–æ–ø–æ–∫ –≤ –æ–¥–∏–Ω –≤—ã–∑–æ–≤ editMessageText
        await ctx.editMessageText(
            `–í—ã–±—Ä–∞–Ω–Ω—ã–µ –º–µ—Å—Ç–∞:\n${selectedSeatsString}\n\n–¢–µ–∫—É—â–∏–π –≤—ã–±–æ—Ä:\n–°–µ–∫—Ü–∏—è ${sectionName}, –†—è–¥ ${rowNumber}\n–í—ã–±–µ—Ä–∏—Ç–µ –º–µ—Å—Ç–æ:`,
            Markup.inlineKeyboard(seatButtons, { columns: 3 })
        );
    } catch (error) {
        console.error("Error updating message:", error);
        ctx.reply("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —Å–æ–æ–±—â–µ–Ω–∏—è. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.");
    }
});

async function checkCellColorBulk(seats: { section: string; row: number; seat: number }[]): Promise<{ [key: string]: boolean | null }> {
    try {
        await doc.loadInfo(); // Load sheet info once outside the loop
        const results: { [key: string]: boolean | null } = {};

        const sheetsToLoad: { [section: string]: boolean } = {}; // Track which sheets need loading

        for (const seat of seats) {
            if (!sheetsToLoad[seat.section]) {
                sheetsToLoad[seat.section] = true;
            }
        }

        const sheetPromises = Object.keys(sheetsToLoad).map(async sectionName => {
            const sheet = doc.sheetsByTitle[sectionName];
            if (sheet) {
                await sheet.loadCells('A1:AH30');
                return { sectionName, sheet };
            }
            return null;
        });

        const loadedSheets = await Promise.all(sheetPromises);

        const sheetsBySection: { [sectionName: string]: GoogleSpreadsheetWorksheet } = {};
        for (const loadedSheet of loadedSheets) {
            if (loadedSheet) {
                sheetsBySection[loadedSheet.sectionName] = loadedSheet.sheet;
            }
        }


        for (const seat of seats) {
            const sheet = sheetsBySection[seat.section];

            if (!sheet) {
                results[`${seat.section}-${seat.row}-${seat.seat}`] = null; // Sheet not found or error
                continue;
            }

            const colLetter = numToColLetter(seat.seat);
            const cell = sheet.getCellByA1(`${colLetter}${seat.row}`);
            const isBooked = cell.value;

            if (typeof isBooked === 'boolean') {
                results[`${seat.section}-${seat.row}-${seat.seat}`] = isBooked;
            } else if (isBooked === "TRUE" || isBooked === "FALSE") {
                results[`${seat.section}-${seat.row}-${seat.seat}`] = isBooked === "TRUE";
            } else {
                results[`${seat.section}-${seat.row}-${seat.seat}`] = null; // Unexpected value, handle as needed
            }
        }

        return results;
    } catch (error) {
        console.error('Error checking cell colors in bulk:', error);
        // Handle the error as needed, perhaps returning an empty object or throwing the error
        return {}; // Or throw error
    }
}

async function updateSeatsAndSheet(seats: { section: string; row: number; seat: number }[], userId: number, isBooking: boolean, ctx: TgContext) {
    try {
        await doc.loadInfo(); // Load sheet info once outside the loop

        const client = await pool.connect();
        try {
            await client.query('BEGIN'); // Start transaction

            const sheetsToUpdate: { [section: string]: GoogleSpreadsheetWorksheet } = {};

            for (const seat of seats) {
                // Update database
                const query = `
                    UPDATE seats 
                    SET is_booked = $1, booked_by = $2
                    WHERE row_id = (SELECT id FROM rows WHERE section_id = (SELECT id FROM sections WHERE name = $3) AND row_number = $4)
                    AND seat_number = $5
                    RETURNING *;  -- Return updated rows for verification
                `;

                const values = [isBooking, isBooking ? userId : null, seat.section, seat.row, seat.seat];
                const { rowCount, rows: updatedRows } = await client.query(query, values);

                if (rowCount !== 1) {
                    throw new Error(`Failed to update seat: ${seat.section}, ${seat.row}, ${seat.seat}. Row count: ${rowCount}`);
                }


                let sheet = sheetsToUpdate[seat.section]; //Check if sheet is already loaded

                if (!sheet) {   //Load sheet only if it's not already loaded
                    sheet = doc.sheetsByTitle[seat.section];
                    if (!sheet) {
                        sheet = await doc.addSheet({ title: seat.section });
                    }

                    await sheet.loadCells('A1:AH30'); //Load cells for the section
                    sheetsToUpdate[seat.section] = sheet; //Store loaded sheet for reuse
                }

                const colLetter = numToColLetter(seat.seat);
                const cell = sheet.getCellByA1(`${colLetter}${seat.row}`);
                cell.value = isBooking;

            }


            const updatePromises = Object.values(sheetsToUpdate).map(sheet => sheet.saveUpdatedCells()); // Update all modified sheets
            await Promise.all(updatePromises);

            await client.query('COMMIT'); // Commit transaction

        } catch (error) {
            await client.query('ROLLBACK'); // Rollback transaction on error
            console.error('Error updating seats:', error);
            ctx.reply('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.');

            throw error; // Re-throw the error to be handled by the calling function
        } finally {
            client.release();
        }

    } catch (sheetError) {
        console.error('Error loading sheet info:', sheetError);
        ctx.reply('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.');

    }
}

async function getSections() {
    const client = await pool.connect();
    try {
        const { rows } = await client.query('SELECT name FROM sections');
        return rows;
    } finally {
        client.release();
    }
}


async function getRows(sectionName: string) {
    const client = await pool.connect();
    try {
        const { rows } = await client.query(
            `SELECT rows.row_number, COUNT(seats.id) AS total_seats,
             (SELECT COUNT(s.id) FROM seats s JOIN rows r ON s.row_id = r.id JOIN sections sec ON r.section_id = sec.id WHERE sec.name = $1 AND r.row_number = rows.row_number AND s.is_booked = FALSE) AS free_seats
             FROM rows
             JOIN sections ON rows.section_id = sections.id
             LEFT JOIN seats ON rows.id = seats.row_id
             WHERE sections.name = $1
             GROUP BY rows.row_number
             ORDER BY rows.row_number ASC`, // Add ORDER BY clause here
            [sectionName]
        );
        return rows;
    } finally {
        client.release();
    }
}


async function getSeats(sectionName: string, rowNumber: number, ctx: TgContext) {
    const client = await pool.connect();
    try {
        const { rows } = await client.query(
            `SELECT seats.seat_number, seats.booked_by, seats.is_booked
             FROM seats
             JOIN rows ON seats.row_id = rows.id
             JOIN sections ON rows.section_id = sections.id
             WHERE sections.name = $1
             AND rows.row_number = $2
             ORDER BY seats.seat_number;`, // ORDER BY –¥–ª—è —É–ø–æ—Ä—è–¥–æ—á–∏–≤–∞–Ω–∏—è
            [sectionName, rowNumber]
        );

        const selectedSeats = ctx.session?.selectedSeats || [];
        const userId = (await client.query(`SELECT id FROM users WHERE telegram_id = $1`, [ctx.from?.id]))?.rows?.[0]?.id;

        const seatsWithSelection = rows.map(seat => ({
            ...seat,
            isSelected: selectedSeats.some(s => s.section === sectionName && s.row === rowNumber && s.seat === seat.seat_number),
            isBookedByUser: seat.booked_by === userId,
            isBooked: seat.is_booked
        }));

        return seatsWithSelection;
    } finally {
        client.release();
    }
}

function getSelectedSeatsString(ctx: TgContext) {
    return ctx.session && ctx.session.selectedSeats ? ctx.session.selectedSeats.map(s => `–°–µ–∫—Ü–∏—è ${s.section}, –†—è–¥ ${s.row}, –ú–µ—Å—Ç–æ ${s.seat}`).join('\n') : "";
}

// –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–æ–∫ "–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å"
bot.action('confirm_booking', async (ctx) => {
    if (!ctx.session?.selectedSeats || ctx.session.selectedSeats.length === 0) {
        return ctx.reply('–í—ã –Ω–µ –≤—ã–±—Ä–∞–ª–∏ –º–µ—Å—Ç–∞ –¥–ª—è –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è. –í–≤–µ–¥–∏—Ç–µ /book –¥–ª—è –≤—ã–±–æ—Ä–∞ –º–µ—Å—Ç.');
    }

    await ctx.deleteMessage(); // Delete the seats selection message

    const bookedSeats: { section: string; row: number; seat: number }[] = [];
    const successfullySelectedSeats: { section: string; row: number; seat: number }[] = [];

    const availability = await checkCellColorBulk(ctx.session.selectedSeats || []);

    for (const seat of ctx.session.selectedSeats || []) {
        const key = `${seat.section}-${seat.row}-${seat.seat}`;
        const isBooked = availability[key];

        if (isBooked === true || isBooked === null) {
            bookedSeats.push(seat);
        } else {
            successfullySelectedSeats.push(seat)
        }
    }

    if (bookedSeats.length > 0) {
        await checkSpreadsheetChanges();
        const bookedSeatsString = bookedSeats.map(s => `–°–µ–∫—Ü–∏—è ${s.section}, –†—è–¥ ${s.row}, –ú–µ—Å—Ç–æ ${s.seat}`).join('\n');
        //Alert user about already booked seats using a single message with an edit
        if (successfullySelectedSeats.length === 0) { //if all the selected seats were already booked
            ctx.reply(`‚ö†Ô∏è–°–ª–µ–¥—É—é—â–∏–µ –º–µ—Å—Ç–∞ —É–∂–µ –∑–∞–±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω—ã:\n${bookedSeatsString}\n–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –¥—Ä—É–≥–∏–µ –º–µ—Å—Ç–∞.`);
            ctx.session.selectedSeats = [];
            ctx.session.step = BOOKING_STEPS.SELECT_SECTION;
            return startBooking(ctx); // Call the startBooking function
        }
        else { //if some of the seats are already booked, show the list of available seats in the selection
            ctx.session.selectedSeats = successfullySelectedSeats;
            const lastSelectedSeat = ctx.session.selectedSeats[ctx.session.selectedSeats.length - 1];

            const seats = await getSeats(lastSelectedSeat.section, lastSelectedSeat.row, ctx);
            const seatButtons = seats.map(seat => {
                let label = `–ú–µ—Å—Ç–æ ${seat.seat_number}`;
                if (seat.isSelected) {
                    label += " ‚úÖ";
                } else if (seat.isBookedByUser) {
                    label += " üë§";
                } else if (seat.isBooked) {
                    label += " ‚ùå";
                }
                return Markup.button.callback(label, `seat_${lastSelectedSeat.section}_${lastSelectedSeat.row}_${seat.seat_number}`)
            });

            seatButtons.push(Markup.button.callback('–ù–∞–∑–∞–¥', `back_to_row_${lastSelectedSeat.section}`));
            if (ctx.session.selectedSeats.length > 0) {
                seatButtons.push(Markup.button.callback('–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å', 'confirm_booking'));
            }

            const selectedSeatsString = getSelectedSeatsString(ctx);

            return ctx.reply(`‚ö†Ô∏è–ù–µ–∫–æ—Ç–æ—Ä—ã–µ –∏–∑ –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö –≤–∞–º–∏ –º–µ—Å—Ç –±—ã–ª–∏ —É–∂–µ –∑–∞–±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω—ã:\n${bookedSeatsString}\n\n–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –¥—Ä—É–≥–∏–µ –º–µ—Å—Ç–∞.\n\n–í—ã–±—Ä–∞–Ω–Ω—ã–µ –º–µ—Å—Ç–∞:\n${selectedSeatsString}\n\n–¢–µ–∫—É—â–∏–π –≤—ã–±–æ—Ä:\n–°–µ–∫—Ü–∏—è ${lastSelectedSeat.section}, –†—è–¥ ${lastSelectedSeat.row}\n–í—ã–±–µ—Ä–∏—Ç–µ –º–µ—Å—Ç–æ:`,
                Markup.inlineKeyboard(seatButtons, { columns: 3 }));
        }


    } else { //  Proceed to get user details if no seats are booked
        ctx.reply('–í–≤–µ–¥–∏—Ç–µ –§–ò–û —Ä–µ–±—ë–Ω–∫–∞ (—É—á–∞—Å—Ç–Ω–∏–∫–∞ –∫–æ–Ω—Ü–µ—Ä—Ç–∞):');
        ctx.session.step = BOOKING_STEPS.AWAITING_FULL_NAME;
    }
});


// –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∫–Ω–æ–ø–æ–∫ "–ù–∞–∑–∞–¥"
bot.action('back_to_section', async (ctx) => {
    if (ctx.session == undefined) {
        return ctx.reply('–í–≤–µ–¥–∏—Ç–µ /book –¥–ª—è –Ω–∞—á–∞–ª–∞ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è.');
    }
    ctx.session.step = BOOKING_STEPS.SELECT_SECTION;
    const sections = await getSections();

    if (sections.length === 0) {
        return ctx.reply('–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Å–µ–∫—Ü–∏–π.');
    }

    const sectionButtons = sections.map((section) =>
        Markup.button.callback(section.name, `section_${section.name}`)
    );

    const selectedSeatsString = getSelectedSeatsString(ctx);
    return ctx.editMessageText(`–í—ã–±—Ä–∞–Ω–Ω—ã–µ –º–µ—Å—Ç–∞:\n${selectedSeatsString}\n–í—ã–±–µ—Ä–∏—Ç–µ —Å–µ–∫—Ü–∏—é:`, Markup.inlineKeyboard(sectionButtons, { columns: 2 }));

});

// Add cancel_booking action
bot.action('cancel_booking', async (ctx) => {
    if (ctx.session) {
        ctx.session.selectedSeats = [];
        ctx.session.step = undefined;
    }
    ctx.editMessageText('–ë—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ.');
    await ctx.answerCbQuery();  // Important: Acknowledge the callback query
});

bot.action(/back_to_row_(.+)/, async (ctx) => {
    const sectionName = ctx.match[1];
    if (!ctx.session) {
        return ctx.reply('–í–≤–µ–¥–∏—Ç–µ /book –¥–ª—è –Ω–∞—á–∞–ª–∞ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è.');
    }

    ctx.session.step = BOOKING_STEPS.SELECT_ROW;

    const rows = await getRows(sectionName);
    const rowButtons = rows.map((row) =>
        Markup.button.callback(`–†—è–¥ ${row.row_number} (${row.free_seats}/${row.total_seats})`, `row_${sectionName}_${row.row_number}`)
    );
    rowButtons.push(Markup.button.callback('–ù–∞–∑–∞–¥', 'back_to_section'));
    rowButtons.push(Markup.button.callback('–û—Ç–º–µ–Ω–∞', 'cancel_booking'));

    const selectedSeatsString = getSelectedSeatsString(ctx);
    ctx.editMessageText(`–í—ã–±—Ä–∞–Ω–Ω—ã–µ –º–µ—Å—Ç–∞:\n${selectedSeatsString}\n\n–¢–µ—É—â–∏–π –≤—ã–±–æ—Ä:\n–°–µ–∫—Ü–∏—è ${sectionName}\n–í—ã–±–µ—Ä–∏—Ç–µ —Ä—è–¥:`, Markup.inlineKeyboard(rowButtons, { columns: 3 }));
});

// –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /mybookings
bot.command('mybookings', async (ctx) => {
    const client = await pool.connect();
    try {
        const { rows: bookings } = await client.query(
            `SELECT sections.name AS section_name, rows.row_number, seats.seat_number
       FROM seats
       JOIN rows ON rows.id = seats.row_id
       JOIN sections ON sections.id = rows.section_id
       WHERE seats.booked_by = (SELECT id FROM users WHERE telegram_id = $1);
      `,
            [ctx.from?.id]
        );

        if (bookings.length === 0) {
            ctx.reply('–£ –≤–∞—Å –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –±—Ä–æ–Ω–µ–π.');
            return;
        }

        const message = bookings
            .map((b) => `–°–µ–∫—Ü–∏—è: ${b.section_name}, –†—è–¥: ${b.row_number}, –ú–µ—Å—Ç–æ: ${b.seat_number}`)
            .join('\n');

        ctx.reply(`–í–∞—à–∏ –±—Ä–æ–Ω–∏:\n${message}\n–î–ª—è –æ—Ç–º–µ–Ω—ã –±—Ä–æ–Ω–∏ –≤–≤–µ–¥–∏—Ç–µ /cancel.`);
    } catch (error) {
        console.error('Error fetching bookings:', error);
        ctx.reply('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –≤–∞—à–∏—Ö –±—Ä–æ–Ω–µ–π. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.');
    } finally {
        client.release();
    }
});

// –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /cancel
bot.command('cancel', async (ctx) => {
    const client = await pool.connect();
    try {
        const userId = (await client.query(`SELECT id FROM users WHERE telegram_id = $1`, [ctx.from?.id]))?.rows?.[0]?.id;

        if (!userId) {
            ctx.reply('–£ –≤–∞—Å –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –±—Ä–æ–Ω–µ–π.');
            return;
        }

        ctx.session = { selectedSeats: [], step: 'cancel_seat' }; // Initialize session for cancellation

        const sections = await getCancellableSections(userId); // Get sections with bookable seats by this user


        if (sections.length === 0) {
            ctx.reply('–£ –≤–∞—Å –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –±—Ä–æ–Ω–µ–π.');
            delete ctx.session.step;  //Clear session if no bookings
            return;
        }

        const sectionButtons = sections.map((section) =>
            Markup.button.callback(section.name, `cancel_section_${section.name}`)
        );


        ctx.reply('–í—ã–±–µ—Ä–∏—Ç–µ —Å–µ–∫—Ü–∏—é –¥–ª—è –æ—Ç–º–µ–Ω—ã –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è:', Markup.inlineKeyboard(sectionButtons, { columns: 2 }));


    } catch (error) {
        console.error('Error fetching bookings for cancellation:', error);
        ctx.reply('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –≤–∞—à–∏—Ö –±—Ä–æ–Ω–µ–π. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.');
        if (ctx.session != undefined)
            delete ctx.session.step;  //Clear session in case of error
    } finally {
        client.release();
    }
});


async function getCancellableSections(userId: number) {
    const client = await pool.connect();
    try {
        const { rows } = await client.query(
            `SELECT DISTINCT sections.name
             FROM seats
             JOIN rows ON seats.row_id = rows.id
             JOIN sections ON rows.section_id = sections.id
             WHERE seats.booked_by = $1`,
            [userId]
        );
        return rows;
    } finally {
        client.release();
    }
}


async function getCancellableRows(sectionName: string, ctx: TgContext) {
    const client = await pool.connect();
    try {
        const userId = (await client.query(`SELECT id FROM users WHERE telegram_id = $1`, [ctx.from?.id]))?.rows?.[0]?.id;
        const { rows } = await client.query(
            `SELECT DISTINCT rows.row_number
             FROM seats
             JOIN rows ON seats.row_id = rows.id
             JOIN sections ON rows.section_id = sections.id
             WHERE sections.name = $1 AND seats.booked_by = $2`,
            [sectionName, userId]
        );
        return rows;
    } finally {
        client.release();
    }
}


async function getCancellableSeats(sectionName: string, rowNumber: number, ctx: TgContext) {
    const client = await pool.connect();
    try {

        const userId = (await client.query(`SELECT id FROM users WHERE telegram_id = $1`, [ctx.from?.id]))?.rows?.[0]?.id;
        const { rows } = await client.query(
            `SELECT seats.seat_number
             FROM seats
             JOIN rows ON seats.row_id = rows.id
             JOIN sections ON rows.section_id = sections.id
             WHERE sections.name = $1
             AND rows.row_number = $2 AND seats.booked_by = $3
             ORDER BY seats.seat_number;`,
            [sectionName, rowNumber, userId]
        );
        return rows;
    } finally {
        client.release();
    }
}


bot.on('text', async (ctx) => {
    const client = await pool.connect();
    try {
        if (ctx.session?.step === BOOKING_STEPS.AWAITING_FULL_NAME) {
            ctx.session.fullName = ctx.message.text.trim();

            // –í–∞–ª–∏–¥–∞—Ü–∏—è –§–ò–û (–º–∏–Ω–∏–º—É–º 2 —Å–ª–æ–≤–∞)
            if (ctx.session.fullName.split(/\s+/).length < 2) {
                ctx.reply('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –§–∞–º–∏–ª–∏—é –∏ –ò–º—è —Ü–µ–ª–∏–∫–æ–º');
                return;
            }

            ctx.reply('–í–≤–µ–¥–∏—Ç–µ –≤–∞—à –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ —Å –∫–æ–¥–æ–º –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞ –≤ —Ñ–æ—Ä–º–∞—Ç–µ +375291111111:');
            ctx.session.step = BOOKING_STEPS.AWAITING_PHONE_NUMBER;
        } else if (ctx.session?.step === BOOKING_STEPS.AWAITING_PHONE_NUMBER) {
            const phoneNumber = ctx.message.text.trim();
            // –í–∞–ª–∏–¥–∞—Ü–∏—è –Ω–æ–º–µ—Ä–∞ —Ç–µ–ª–µ—Ñ–æ–Ω–∞ (–ø—Ä–æ—Å—Ç–æ–π –ø—Ä–∏–º–µ—Ä, –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –±–æ–ª–µ–µ —Å–ª–æ–∂–Ω—ã–µ —Ä–µ–≥—É–ª—è—Ä–Ω—ã–µ –≤—ã—Ä–∞–∂–µ–Ω–∏—è)
            if (!/^\+?\d{12}$/.test(phoneNumber)) {
                ctx.reply('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, +375291111111).');
                return;
            }

            // Check if the phone number already exists, BUT EXCLUDE the current user
            const { rows: existingUser } = await client.query(
                'SELECT * FROM users WHERE phone_number = $1 AND telegram_id != $2',
                [phoneNumber, ctx.from?.id]
            );

            if (existingUser.length > 0) {
                ctx.reply('–≠—Ç–æ—Ç –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ —É–∂–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –¥—Ä—É–≥–æ–π –Ω–æ–º–µ—Ä.');
                return; // Stop further processing
            }

            ctx.session.phoneNumber = phoneNumber;

            const { rows: userRows } = await client.query(
                `INSERT INTO users (full_name, phone_number, telegram_id) 
         VALUES ($1, $2, $3) 
         ON CONFLICT (telegram_id) DO UPDATE SET full_name = EXCLUDED.full_name, phone_number = EXCLUDED.phone_number
         RETURNING id;`,
                [ctx.session.fullName, ctx.session.phoneNumber, ctx.from?.id]
            );

            const userId = userRows[0].id;

            for (const seat of ctx.session.selectedSeats || []) {
                const { rows: seatCheck } = await client.query(
                    `SELECT is_booked FROM seats 
                     JOIN rows ON seats.row_id = rows.id
                     JOIN sections ON rows.section_id = sections.id
                     WHERE sections.name = $1
                     AND rows.row_number = $2
                     AND seats.seat_number = $3
                     AND is_booked = FALSE;`, // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –º–µ—Å—Ç–æ –≤—Å–µ –µ—â–µ —Å–≤–æ–±–æ–¥–Ω–æ
                    [seat.section, seat.row, seat.seat]
                );

                if (seatCheck.length === 0) {  // –ú–µ—Å—Ç–æ —É–∂–µ –∑–∞–±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–æ –∫–µ–º-—Ç–æ –¥—Ä—É–≥–∏–º
                    ctx.reply(`–ú–µ—Å—Ç–æ ${seat.seat} –≤ —Å–µ–∫—Ü–∏–∏ ${seat.section}, —Ä—è–¥ ${seat.row} —É–∂–µ –∑–∞–±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–æ. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –¥—Ä—É–≥–æ–µ –º–µ—Å—Ç–æ.`);
                    return; // –ü—Ä–µ—Ä—ã–≤–∞–µ–º –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ
                }
            }

            try {
                await updateSeatsAndSheet(ctx.session.selectedSeats || [], userId, true, ctx);
                ctx.reply('–ë—Ä–æ–Ω—å —É—Å–ø–µ—à–Ω–æ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞. –°–ø–∞—Å–∏–±–æ!\n–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /mybookings –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –±—Ä–æ–Ω–µ–π.\n–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /cancel –¥–ª—è –æ—Ç–º–µ–Ω–∏ –±—Ä–æ–Ω–∏\n–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /book –¥–ª—è –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã—Ö –º–µ—Å—Ç');
                ctx.session = {};
            } catch (error) {
                // Error is already handled in updateSeatsAndSheet
            }
        }
        else {
            ctx.reply('–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É /book –¥–ª—è –Ω–∞—á–∞–ª–∞ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è –∏–ª–∏ /mybookings –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –±—Ä–æ–Ω–µ–π.');
        }
    } catch (error) {
        console.error('Error processing cancellation:', error);
        ctx.reply('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–∏. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.');
    } finally {
        client.release();
    }
});

async function checkSpreadsheetChanges() {
    try {
        await doc.loadInfo();
        const client = await pool.connect();

        try {
            const { rows: dbSections } = await client.query(`SELECT DISTINCT name FROM sections`);
            const sectionNames = dbSections.map(section => section.name);

            const sheets = await Promise.all(sectionNames.map(async sectionName => {
                const sheet = doc.sheetsByTitle[sectionName];
                if (sheet) {
                    await sheet.loadCells('A1:AH30');
                    return sheet;
                }
                return null;
            }));

            const sheetsBySectionName = sectionNames.reduce((acc, sectionName, index) => {
                const sheet = sheets[index];
                if (sheet) {
                    acc[sectionName] = sheet;
                }
                return acc;
            }, {});

            const { rows: dbSeats } = await client.query(
                `SELECT sections.name AS section_name, rows.row_number, seats.seat_number
                 FROM seats
                 JOIN rows ON seats.row_id = rows.id
                 JOIN sections ON rows.section_id = sections.id`
            );

            for (const dbSeat of dbSeats) {
                const sheet = sheetsBySectionName[dbSeat.section_name];
                if (!sheet) continue;

                const colLetter = numToColLetter(dbSeat.seat_number);
                const cell = sheet.getCellByA1(`${colLetter}${dbSeat.row_number}`);


                // Directly get the boolean value
                const isBookedInSpreadsheet = cell.value;

                // Handle cases where the value is not a boolean
                let isBookedBool = null;
                if (typeof isBookedInSpreadsheet === 'boolean') {
                    isBookedBool = isBookedInSpreadsheet;
                } else if (isBookedInSpreadsheet === "TRUE" || isBookedInSpreadsheet === "FALSE") {
                    isBookedBool = isBookedInSpreadsheet === "TRUE";
                }

                if (isBookedBool !== null) { // Proceed only if we have a valid boolean value
                    const { rows: dbSeatInfo } = await client.query(
                        `SELECT is_booked FROM seats
                         JOIN rows ON seats.row_id = rows.id
                         JOIN sections ON rows.section_id = sections.id
                         WHERE sections.name = $1 AND rows.row_number = $2 AND seats.seat_number = $3`,
                        [dbSeat.section_name, dbSeat.row_number, dbSeat.seat_number]
                    );
                    const isBookedInDb = dbSeatInfo[0]?.is_booked;


                    if (isBookedBool && !isBookedInDb) {
                        await handleRedCell(dbSeat.section_name, dbSeat.row_number, dbSeat.seat_number, client);
                    } else if (!isBookedBool && isBookedInDb) {
                        await handleGreenCell(dbSeat.section_name, dbSeat.row_number, dbSeat.seat_number, client);
                    }
                }

            }
        } finally {
            client.release();
        }
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ –∏–∑–º–µ–Ω–µ–Ω–∏–π:', error);
    }
}


async function handleRedCell(sectionName: string, rowNumber: number, seatNumber: number, client: any): Promise<void> {
    try {

        // –ó–∞–±—Ä–æ–Ω–∏—Ä–æ–≤–∞—Ç—å –º–µ—Å—Ç–æ –≤ –ë–î, –µ—Å–ª–∏ –æ–Ω–æ –Ω–µ –∑–∞–±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–æ
        const { rowCount } = await client.query(
            `UPDATE seats SET is_booked = TRUE
             WHERE row_id = (SELECT id FROM rows WHERE section_id = (SELECT id FROM sections WHERE name = $1) AND row_number = $2)
             AND seat_number = $3 AND is_booked = FALSE
             RETURNING *;`,
            [sectionName, rowNumber, seatNumber]
        );

    }
    catch (error) {
        console.log(error);
    }
}

async function handleGreenCell(sectionName: string, rowNumber: number, seatNumber: number, client: any): Promise<void> {
    try {

        // –û—Ç–º–µ–Ω–∏—Ç—å –±—Ä–æ–Ω—å –∏ –æ—Å–≤–æ–±–æ–¥–∏—Ç—å –º–µ—Å—Ç–æ
        const { rows: bookingInfo } = await client.query(
            `UPDATE seats SET is_booked = FALSE, booked_by = NULL
             WHERE row_id = (SELECT id FROM rows WHERE section_id = (SELECT id FROM sections WHERE name = $1) AND row_number = $2)
             AND seat_number = $3
             RETURNING booked_by;`,
            [sectionName, rowNumber, seatNumber]
        );

        const bookedByUserId = bookingInfo[0]?.booked_by;
        if (bookedByUserId) {
            // –£–≤–µ–¥–æ–º–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –æ–± –æ—Ç–º–µ–Ω–µ –±—Ä–æ–Ω–∏ (–µ—Å–ª–∏ –µ—Å—Ç—å booked_by)
            const { rows: telegramIdRows } = await client.query(`SELECT telegram_id FROM users WHERE id = $1`, [bookedByUserId]);
            const telegramId = telegramIdRows[0]?.telegram_id;
            if (telegramId) {
                try {
                    await bot.telegram.sendMessage(telegramId, `–í–∞—à–∞ –±—Ä–æ–Ω—å –Ω–∞ –º–µ—Å—Ç–æ ${seatNumber} –≤ —Å–µ–∫—Ü–∏–∏ ${sectionName}, —Ä—è–¥ ${rowNumber} –±—ã–ª–∞ –æ—Ç–º–µ–Ω–µ–Ω–∞.`);
                } catch (telegramError) {
                    console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Å–æ–æ–±—â–µ–Ω–∏—è –≤ Telegram:', telegramError);
                }
            }
        }
    }
    catch (error) {
        console.log(error);
    }
}

function numToColLetter(num: number) {
    let colLetter = "";
    while (num > 0) {
        let remainder = (num - 1) % 26;
        colLetter = String.fromCharCode(65 + remainder) + colLetter;
        num = Math.floor((num - 1) / 26);
    }
    return colLetter;
}

// –ó–∞–ø—É—Å–∫–∞–µ–º –ø—Ä–æ–≤–µ—Ä–∫—É –∏–∑–º–µ–Ω–µ–Ω–∏–π –∫–∞–∂–¥—É—é –º–∏–Ω—É—Ç—É
setInterval(checkSpreadsheetChanges, 60 * 1000);

async function fetchDataAndWriteToSheet() {
    const client = await pool.connect();
    try {
        const { rows: data } = await client.query(`
            SELECT
                u.full_name as "–§–ò–û",
                u.phone_number as "–¢–µ–ª–µ—Ñ–æ–Ω",
                s.name as "–°–µ–∫—Ü–∏—è",
                r.row_number as "–†—è–¥",
                json_agg(st.seat_number ORDER BY st.seat_number) AS "–ú–µ—Å—Ç–æ"
            FROM
                users u
            LEFT JOIN
                seats st ON u.id = st.booked_by
            LEFT JOIN
                rows r ON st.row_id = r.id
            LEFT JOIN
                sections s ON r.section_id = s.id
            WHERE st.booked_by IS NOT NULL
            GROUP BY
                u.id, u.full_name, u.phone_number, s.name, r.row_number
            ORDER BY u.id, s.name, r.row_number;
        `);

        await writeToGoogleSheet(data);

    } catch (error) {
        console.error('Error fetching data or writing to sheet:', error);
    } finally {
        client.release();
    }
}

async function writeToGoogleSheet(data: any[]) {
    try {
        await bookingsDoc.loadInfo();
        const sheet = await ensureSheetExistsInDoc(bookingsDoc, booking_sheet_name!);
        await sheet.loadCells();


        const lastRow = sheet.rowCount; //Get the last row containing data


        await sheet.clear(`A2:E${lastRow}`); // Clear all existing data EXCEPT the header row


        await sheet.setHeaderRow(['–§–ò–û', '–¢–µ–ª–µ—Ñ–æ–Ω', '–°–µ–∫—Ü–∏–∏', '–†—è–¥—ã', '–ú–µ—Å—Ç–∞', '–û–ø–ª–∞—Ç–∞']);

        const rowsToAdd = [];
        let previousFio = "";
        let previousPhone = "";


        for (const item of data) {
            const fioToAdd = item.–§–ò–û !== previousFio ? item.–§–ò–û : null;
            const phoneToAdd = item.–¢–µ–ª–µ—Ñ–æ–Ω !== previousPhone ? item.–¢–µ–ª–µ—Ñ–æ–Ω : null;

            const seatsArray = Array.isArray(item.–ú–µ—Å—Ç–æ) ? item.–ú–µ—Å—Ç–æ : [item.–ú–µ—Å—Ç–æ];

            rowsToAdd.push([fioToAdd, phoneToAdd, item.–°–µ–∫—Ü–∏—è, `'` + item.–†—è–¥.toString(), `'` + seatsArray.join(', ')]);
            previousFio = item.–§–ò–û;
            previousPhone = item.–¢–µ–ª–µ—Ñ–æ–Ω;
        }

        if (rowsToAdd.length > 0)
            await sheet.addRows(rowsToAdd); //Add rows only if rowsToAdd isn't empty

    } catch (error) {
        console.error('Error writing to Google Sheet:', error);
    }
}

async function ensureSheetExistsInDoc(doc: GoogleSpreadsheet, title: string): Promise<GoogleSpreadsheetWorksheet> {
    try {
        let sheet = doc.sheetsByTitle[title];
        if (!sheet) {
            sheet = await doc.addSheet({ title });
        }
        return sheet;
    } catch (error) {
        console.error(`Error creating sheet "${title}" in document:`, error);
        throw error;
    }
}



// Schedule the function to run every minute
setInterval(fetchDataAndWriteToSheet, 60 * 1000);

// –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞
bot.launch();

// –û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Ä–∞–±–æ—Ç—ã
process.once('SIGINT', () => bot.stop('SIGINT'));
process.once('SIGTERM', () => bot.stop('SIGTERM'));
